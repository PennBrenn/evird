<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Empty Freeway</title>
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; cursor: none; }
  canvas { display: block; filter: contrast(1.07) saturate(0.86) brightness(1.02); }

  #vignette {
    position: fixed; inset: 0; z-index: 4;
    pointer-events: none;
    background: radial-gradient(ellipse at 50% 48%, transparent 48%, rgba(0,0,0,0.58) 100%);
  }

  /* ── Rearview mirror frame ───────────────────────────────── */
  #mirror-frame {
    position: fixed;
    top: 38px;
    left: 50%;
    transform: translateX(-50%);
    width: 22vw;
    min-width: 180px;
    max-width: 400px;
    aspect-ratio: 4.2 / 1;
    border: 1.5px solid rgba(55, 55, 55, 0.45);
    border-radius: 3px;
    z-index: 5;
    pointer-events: none;
    box-shadow: inset 0 0 14px rgba(0,0,0,0.8), 0 0 6px rgba(0,0,0,0.4);
  }

  #sols {
    position: fixed;
    top: 16px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 8;
    color: rgba(150, 145, 135, 0.35);
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.68rem;
    letter-spacing: 0.35em;
    text-transform: uppercase;
    pointer-events: none;
    user-select: none;
    transition: all 0.4s ease;
  }
  #sols.sign-mode {
    background: rgba(0, 75, 38, 0.88);
    color: rgba(255, 255, 255, 0.92);
    padding: 6px 18px;
    border: 1.5px solid rgba(255, 255, 255, 0.55);
    border-radius: 2px;
    font-size: 0.72rem;
    letter-spacing: 0.22em;
  }

  #crash-overlay {
    position: fixed; inset: 0; z-index: 10;
    display: none; flex-direction: column;
    align-items: center; justify-content: center; gap: 16px;
    background: rgba(0,0,0,0);
    transition: background 0.9s ease;
    pointer-events: none;
  }
  #crash-overlay.active { display: flex; background: rgba(0,0,0,0.78); }
  #crash-overlay .msg {
    color: rgba(180,170,160,0); font-family: 'Courier New', monospace;
    font-size: 1.35rem; letter-spacing: 0.45em; text-transform: uppercase;
    transition: color 1.2s ease 0.3s;
  }
  #crash-overlay.active .msg { color: rgba(180,170,160,0.82); }
  #crash-overlay .sols-final {
    color: rgba(140,135,125,0); font-family: 'Courier New', monospace;
    font-size: 0.72rem; letter-spacing: 0.3em;
    transition: color 1.6s ease 0.9s;
  }
  #crash-overlay.active .sols-final { color: rgba(140,135,125,0.60); }
  #crash-overlay .restart {
    color: rgba(120,115,105,0); font-family: 'Courier New', monospace;
    font-size: 0.58rem; letter-spacing: 0.25em; text-transform: uppercase;
    transition: color 2.2s ease 2.2s;
  }
  #crash-overlay.active .restart { color: rgba(120,115,105,0.45); }
</style>
</head>
<body>

<div id="vignette"></div>
<div id="mirror-frame"></div>
<div id="sols">0 sols</div>
<div id="crash-overlay">
  <span class="msg">Timeline Fractured</span>
  <span class="sols-final"></span>
  <span class="restart">press R</span>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  THE EMPTY FREEWAY — Drift Edition
// ═══════════════════════════════════════════════════════════════════════

// ─────────────────────────────────────────────────────────────────────
//  CONSTANTS
// ─────────────────────────────────────────────────────────────────────

const ROAD_LENGTH     = 1000;
const ROAD_WIDTH      = 14;
const LANE_WIDTH      = 3.5;
const SHOULDER_EXTRA  = 3;

const LAMP_SPACING    = 50;
const LAMP_HEIGHT     = 9;
const LAMP_ARM_REACH  = 3.5;
const NUM_LAMP_SLOTS  = 14;

const FOG_DENSITY     = 0.011;

const BASE_SPEED      = 0.45;
const MAX_SPEED       = 1.4;
const MIN_SPEED       = 0.08;
const ACCEL           = 0.007;
const BRAKE           = 0.014;
const DRAG            = 0.0015;

const MAX_LATERAL     = 6.5;

// Drift physics (gentle, correct direction)
const DRIFT_STEER     = 0.0012;    // steer input → angular velocity
const DRIFT_DAMP      = 0.92;      // angular velocity damping
const DRIFT_GRIP      = 0.06;      // traction recovery
const DRIFT_SLIDE     = 0.18;      // drift angle → lateral force
const DRIFT_FRICTION  = 0.94;      // lateral velocity friction

// Ghost merge
const MERGE_FRAMES    = 520;
const MERGE_START_Y   = -4.5;
const MERGE_START_Z   = 55;

// Rain
const RAIN_COUNT      = 8000;
const RAIN_SPREAD     = 72;
const RAIN_HEIGHT     = 26;
const STREAK_LEN      = 0.38;

// Collision
const COL_HX          = 0.85;
const COL_HZ          = 2.2;

// Wheels
const WHEEL_R         = 0.29;

// Obstacles
const MIN_OBS_SPACING = ROAD_WIDTH * 2;

// Road signs
const SIGN_SPACING    = 280;
const NUM_SIGN_SLOTS  = 5;


// ─────────────────────────────────────────────────────────────────────
//  RENDERER, SCENE, CAMERAS
// ─────────────────────────────────────────────────────────────────────

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping         = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.76;
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x010102);
scene.fog = new THREE.FogExp2(0x010102, FOG_DENSITY);

const camera = new THREE.PerspectiveCamera(66, window.innerWidth / window.innerHeight, 0.1, 600);

// Rearview mirror camera
const mirrorCam = new THREE.PerspectiveCamera(58, 4.2, 0.5, 280);
const mirrorEl  = document.getElementById('mirror-frame');

scene.add(new THREE.AmbientLight(0x14141e, 0.24));

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});


// ─────────────────────────────────────────────────────────────────────
//  ROAD SYSTEM
// ─────────────────────────────────────────────────────────────────────

const asphaltMat = new THREE.MeshStandardMaterial({
  color: 0x1a1a1a, roughness: 0.06, metalness: 0.20
});
const shoulderMat = new THREE.MeshStandardMaterial({
  color: 0x0f0f0f, roughness: 0.22, metalness: 0.08
});
const markingMat = new THREE.MeshStandardMaterial({
  color: 0x55554a, roughness: 0.25, emissive: 0x0a0a08, emissiveIntensity: 0.14
});
const railMat = new THREE.MeshPhongMaterial({
  color: 0x303030, specular: 0x555555, shininess: 30
});
const medianMat = new THREE.MeshStandardMaterial({
  color: 0x222222, roughness: 0.5, metalness: 0.05
});

function createRoadSegment() {
  const g = new THREE.Group();

  const road = new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH), asphaltMat);
  road.rotation.x = -Math.PI / 2;
  road.position.set(0, 0, -ROAD_LENGTH / 2);
  g.add(road);

  const sh = new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH + SHOULDER_EXTRA * 2, ROAD_LENGTH), shoulderMat
  );
  sh.rotation.x = -Math.PI / 2;
  sh.position.set(0, -0.015, -ROAD_LENGTH / 2);
  g.add(sh);

  const dashLen = 4, gapLen = 7, cycle = dashLen + gapLen;
  const nDash = Math.ceil(ROAD_LENGTH / cycle);
  const dashGeo = new THREE.PlaneGeometry(0.13, dashLen);
  for (const lx of [-LANE_WIDTH / 2, LANE_WIDTH / 2]) {
    for (let i = 0; i < nDash; i++) {
      const d = new THREE.Mesh(dashGeo, markingMat);
      d.rotation.x = -Math.PI / 2;
      d.position.set(lx, 0.006, -(i * cycle + dashLen / 2));
      g.add(d);
    }
  }

  const edgeGeo = new THREE.PlaneGeometry(0.14, ROAD_LENGTH);
  for (const sx of [-1, 1]) {
    const e = new THREE.Mesh(edgeGeo, markingMat);
    e.rotation.x = -Math.PI / 2;
    e.position.set(sx * (ROAD_WIDTH / 2 - 0.5), 0.006, -ROAD_LENGTH / 2);
    g.add(e);
  }

  const gRailGeo = new THREE.BoxGeometry(0.07, 0.7, ROAD_LENGTH);
  for (const sx of [-1, 1]) {
    const r = new THREE.Mesh(gRailGeo, railMat);
    r.position.set(sx * (ROAD_WIDTH / 2 + 2), 0.35, -ROAD_LENGTH / 2);
    g.add(r);
    const r2 = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.08, ROAD_LENGTH), railMat);
    r2.position.set(sx * (ROAD_WIDTH / 2 + 2), 0.08, -ROAD_LENGTH / 2);
    g.add(r2);
  }

  const med = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.35, ROAD_LENGTH), medianMat);
  med.position.set(-(ROAD_WIDTH / 2 + 3.0), 0.17, -ROAD_LENGTH / 2);
  g.add(med);

  return g;
}

const segments = [createRoadSegment(), createRoadSegment(), createRoadSegment()];
segments.forEach(s => scene.add(s));


// ─────────────────────────────────────────────────────────────────────
//  STREET LAMPS
// ─────────────────────────────────────────────────────────────────────

const lampPostMat  = new THREE.MeshPhongMaterial({ color: 0x252525, specular: 0x333333, shininess: 15 });
const lampGlassMat = new THREE.MeshBasicMaterial({ color: 0xffe8c0, transparent: true, opacity: 0.75 });

function createLampPost() {
  const g = new THREE.Group();
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.075, 0.10, LAMP_HEIGHT, 6), lampPostMat);
  pole.position.y = LAMP_HEIGHT / 2; g.add(pole);
  const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, LAMP_ARM_REACH, 4), lampPostMat);
  arm.rotation.z = Math.PI / 2;
  arm.position.set(-LAMP_ARM_REACH / 2, LAMP_HEIGHT - 0.15, 0); g.add(arm);
  const housing = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.12, 0.75),
    new THREE.MeshPhongMaterial({ color: 0x1a1a1a }));
  housing.position.set(-LAMP_ARM_REACH, LAMP_HEIGHT - 0.22, 0); g.add(housing);
  const glass = new THREE.Mesh(new THREE.PlaneGeometry(0.38, 0.65), lampGlassMat);
  glass.rotation.x = -Math.PI / 2;
  glass.position.set(-LAMP_ARM_REACH, LAMP_HEIGHT - 0.29, 0); g.add(glass);
  const base = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.12, 6), lampPostMat);
  base.position.y = 0.06; g.add(base);
  return g;
}

const lampPosts = [], lampSpots = [];
for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
  const post = createLampPost(); scene.add(post); lampPosts.push(post);
  const spot = new THREE.SpotLight(0xffe0a0, 380, 95, Math.PI / 2.8, 0.82, 1.6);
  spot.target = new THREE.Object3D();
  scene.add(spot); scene.add(spot.target); lampSpots.push(spot);
}

function updateLamps(prog) {
  const b = Math.floor(prog / LAMP_SPACING) - 4;
  for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
    const idx = b + i, z = idx * LAMP_SPACING;
    const side = (idx % 2 === 0) ? 1 : -1;
    const postX = side * (ROAD_WIDTH / 2 + 2), lightX = side * (ROAD_WIDTH / 2 - 1);
    lampPosts[i].position.set(postX, 0, -z);
    lampPosts[i].scale.x = side;
    lampSpots[i].position.set(lightX, LAMP_HEIGHT, -z);
    lampSpots[i].target.position.set(lightX * 0.3, 0, -z);
  }
}


// ─────────────────────────────────────────────────────────────────────
//  SEDAN MODEL
// ─────────────────────────────────────────────────────────────────────
//  - Fixed wheel orientation (torus rotation.y, not rotation.z)
//  - Front wheels steer via wheel group rotation.y
//  - Headlight glow spheres + taillight glow for mirror visibility
// ─────────────────────────────────────────────────────────────────────

function createSedan(colour) {
  const g = new THREE.Group();
  g.userData.wheelGroups = [];

  const bodyMat   = new THREE.MeshPhongMaterial({ color: colour, specular: 0x666666, shininess: 115 });
  const glassMat  = new THREE.MeshPhongMaterial({ color: 0x080812, specular: 0xaaaaaa, shininess: 140, transparent: true, opacity: 0.58, depthWrite: false });
  const trimMat   = new THREE.MeshPhongMaterial({ color: 0x0c0c0c, specular: 0x444444, shininess: 35 });
  const rubberMat = new THREE.MeshPhongMaterial({ color: 0x080808, specular: 0x0e0e0e, shininess: 6 });
  const chromeMat = new THREE.MeshPhongMaterial({ color: 0x222222, specular: 0x999999, shininess: 90 });

  // ── Extruded body profile ─────────────────────────────────
  const s = new THREE.Shape();
  s.moveTo(-2.32, 0.22); s.lineTo(-2.32, 0.42);
  s.quadraticCurveTo(-2.27, 0.60, -1.88, 0.67);
  s.lineTo(-1.08, 0.72);
  s.bezierCurveTo(-0.82, 0.73, -0.48, 1.16, -0.22, 1.36);
  s.bezierCurveTo(-0.02, 1.445, 0.56, 1.45, 0.76, 1.37);
  s.bezierCurveTo(0.94, 1.22, 1.10, 0.90, 1.28, 0.76);
  s.lineTo(1.88, 0.71);
  s.quadraticCurveTo(2.27, 0.60, 2.32, 0.42);
  s.lineTo(2.32, 0.22); s.lineTo(-2.32, 0.22);

  const BODY_W = 1.84;
  const bodyGeo = new THREE.ExtrudeGeometry(s, {
    depth: BODY_W, bevelEnabled: true,
    bevelThickness: 0.045, bevelSize: 0.045,
    bevelSegments: 3, curveSegments: 16
  });
  const bodyMesh = new THREE.Mesh(bodyGeo, bodyMat);
  bodyMesh.rotation.y = -Math.PI / 2;
  bodyMesh.position.x = BODY_W / 2;
  g.add(bodyMesh);

  // ── Side sills ────────────────────────────────────────────
  for (const sx of [-1, 1]) {
    const sill = new THREE.Mesh(new THREE.BoxGeometry(0.025, 0.06, 3.4), trimMat);
    sill.position.set(sx * (BODY_W / 2 + 0.01), 0.26, 0);
    g.add(sill);
  }

  // ── Glass ─────────────────────────────────────────────────
  const ws = new THREE.Mesh(new THREE.PlaneGeometry(1.52, 0.56), glassMat);
  ws.rotation.x = 0.44; ws.position.set(0, 1.08, -0.88); g.add(ws);
  const rw = new THREE.Mesh(new THREE.PlaneGeometry(1.46, 0.46), glassMat);
  rw.rotation.x = -0.48; rw.position.set(0, 1.05, 0.96); g.add(rw);
  for (const sx of [-1, 1]) {
    const swF = new THREE.Mesh(new THREE.PlaneGeometry(0.72, 0.34), glassMat);
    swF.rotation.y = sx * Math.PI / 2;
    swF.position.set(sx * (BODY_W / 2 + 0.025), 1.12, -0.24); g.add(swF);
    const swR = new THREE.Mesh(new THREE.PlaneGeometry(0.68, 0.32), glassMat);
    swR.rotation.y = sx * Math.PI / 2;
    swR.position.set(sx * (BODY_W / 2 + 0.025), 1.11, 0.40); g.add(swR);
  }

  // ── Wheels (FIXED orientation: torus rotation.y = π/2) ────
  const tireGeo  = new THREE.TorusGeometry(0.29, 0.095, 10, 22);
  const rimGeo   = new THREE.CylinderGeometry(0.21, 0.21, 0.16, 18);
  const hubGeo   = new THREE.CylinderGeometry(0.07, 0.07, 0.18, 10);
  const spokeGeo = new THREE.BoxGeometry(0.03, 0.38, 0.03);

  const wPos = [
    [-0.86, 0.29, -1.36], [0.86, 0.29, -1.36],   // front L, front R
    [-0.86, 0.29,  1.36], [0.86, 0.29,  1.36]     // rear L, rear R
  ];

  for (const [wx, wy, wz] of wPos) {
    const wGroup = new THREE.Group();
    wGroup.position.set(wx, wy, wz);

    // Tire — rotation.y orients torus ring into YZ plane (hole along X)
    const tire = new THREE.Mesh(tireGeo, rubberMat);
    tire.rotation.y = Math.PI / 2;
    wGroup.add(tire);

    // Rim — cylinder axis Y → rotation.z puts axis along X
    const rim = new THREE.Mesh(rimGeo, chromeMat);
    rim.rotation.z = Math.PI / 2;
    wGroup.add(rim);

    // Hub
    const hub = new THREE.Mesh(hubGeo, trimMat);
    hub.rotation.z = Math.PI / 2;
    wGroup.add(hub);

    // Spokes — radiate in YZ plane, rotation.x sets angular position
    for (let si = 0; si < 5; si++) {
      const spoke = new THREE.Mesh(spokeGeo, chromeMat);
      spoke.rotation.x = (si / 5) * Math.PI * 2;
      wGroup.add(spoke);
    }

    g.add(wGroup);
    g.userData.wheelGroups.push(wGroup);
  }

  // ── Headlights + glow halos (visible in rearview mirror) ──
  const hlMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
  const hlGlowMat = new THREE.MeshBasicMaterial({
    color: 0xffffee, transparent: true, opacity: 0.50, depthWrite: false
  });
  const hlGlowOuterMat = new THREE.MeshBasicMaterial({
    color: 0xffeecc, transparent: true, opacity: 0.18, depthWrite: false
  });
  for (const sx of [-0.56, 0.56]) {
    const hl = new THREE.Mesh(
      new THREE.SphereGeometry(0.14, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), hlMat
    );
    hl.rotation.x = Math.PI / 2;
    hl.position.set(sx, 0.54, -2.34);
    g.add(hl);
    // Inner glow halo — bright, visible in rearview mirror
    const glow = new THREE.Mesh(new THREE.SphereGeometry(0.65, 8, 6), hlGlowMat);
    glow.position.set(sx, 0.54, -2.34);
    g.add(glow);
    // Outer glow halo — large soft bloom
    const outerGlow = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 6), hlGlowOuterMat);
    outerGlow.position.set(sx, 0.54, -2.34);
    g.add(outerGlow);
  }

  // ── Taillights + glow ─────────────────────────────────────
  const tlMat = new THREE.MeshBasicMaterial({ color: 0xaa0000 });
  const tlGlowMat = new THREE.MeshBasicMaterial({
    color: 0xff1111, transparent: true, opacity: 0.14, depthWrite: false
  });
  for (const sx of [-0.56, 0.56]) {
    const tl = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.09, 0.04), tlMat);
    tl.position.set(sx, 0.54, 2.34); g.add(tl);
    const ref = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.03, 0.03),
      new THREE.MeshBasicMaterial({ color: 0x660000 }));
    ref.position.set(sx, 0.46, 2.34); g.add(ref);
    // Tail glow halo
    const tGlow = new THREE.Mesh(new THREE.SphereGeometry(0.22, 6, 4), tlGlowMat);
    tGlow.position.set(sx, 0.54, 2.34); g.add(tGlow);
  }

  // ── Chrome bumper strips ──────────────────────────────────
  const bStripGeo = new THREE.BoxGeometry(1.70, 0.04, 0.03);
  const bFront = new THREE.Mesh(bStripGeo, chromeMat);
  bFront.position.set(0, 0.38, -2.35);
  g.add(bFront);
  const bRear = new THREE.Mesh(bStripGeo, chromeMat);
  bRear.position.set(0, 0.38, 2.35);
  g.add(bRear);

  // ── Side mirrors ──────────────────────────────────────────
  for (const sx of [-1, 1]) {
    const stem = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.03, 0.04), trimMat);
    stem.position.set(sx * 0.98, 0.92, -0.52); g.add(stem);
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.05, 8, 6), chromeMat);
    head.position.set(sx * 1.06, 0.92, -0.52); g.add(head);
  }

  // ── Door seams ────────────────────────────────────────────
  for (const sx of [-1, 1]) {
    for (const dz of [-0.12, 0.78]) {
      const seam = new THREE.Mesh(new THREE.BoxGeometry(0.008, 0.40, 0.008), trimMat);
      seam.position.set(sx * (BODY_W / 2 + 0.025), 0.56, dz); g.add(seam);
    }
  }

  return g;
}

/**
 * Spin wheels + steer front pair.
 * Indices 0,1 = front wheels; 2,3 = rear wheels.
 */
function spinWheels(car, spinAngle, frontSteer) {
  const wgs = car.userData.wheelGroups;
  if (!wgs) return;
  for (let i = 0; i < wgs.length; i++) {
    wgs[i].rotation.x = spinAngle;
    if (i < 2) wgs[i].rotation.y = frontSteer || 0;
    else       wgs[i].rotation.y = 0;
  }
}


// ─────────────────────────────────────────────────────────────────────
//  PLAYER
// ─────────────────────────────────────────────────────────────────────

const playerCar = createSedan(0x1e1e28);
scene.add(playerCar);

// Headlights — VERY far reach
function makeHeadlight() {
  const sl = new THREE.SpotLight(0xfff2da, 480, 520, Math.PI / 7.5, 0.38, 1.3);
  sl.target = new THREE.Object3D();
  scene.add(sl); scene.add(sl.target);
  return sl;
}
const hlL = makeHeadlight();
const hlR = makeHeadlight();
const tailGlow = new THREE.PointLight(0x880000, 8, 10, 2);
scene.add(tailGlow);

// State
let progress         = 0;
let currentX         = 0;
let speed            = BASE_SPEED;
let prevSpeed        = BASE_SPEED;
let steer            = 0;
let carPitch         = 0;
let playerWheelSpin  = 0;
let camLagX          = 0;

// Drift state
let driftAngle       = 0;
let driftVel         = 0;
let lateralVel       = 0;


// ─────────────────────────────────────────────────────────────────────
//  GHOST SYSTEM
// ─────────────────────────────────────────────────────────────────────

const allRecordings    = [];
let   currentRecording = [];

class Ghost {
  constructor(recording) {
    this.rec       = recording;
    this.mesh      = createSedan(0x1e1e28);
    this.frame     = 0;
    this.mFrame    = 0;
    this.merged    = false;
    this.wheelSpin = 0;
    this.mesh.visible = true;
    scene.add(this.mesh);
  }

  static ease(t) { return t * t * (3 - 2 * t); }

  update(loopBaseZ) {
    const r = this.rec;
    if (!r.length) return;

    const f    = r[this.frame % r.length];
    const rawZ = -(loopBaseZ + f.z);

    if (!this.merged) {
      this.mFrame++;
      const t = Math.min(this.mFrame / MERGE_FRAMES, 1);
      const sv = Ghost.ease(t);
      this.mesh.position.set(f.x, MERGE_START_Y * (1 - sv), rawZ + MERGE_START_Z * (1 - sv));
      if (t >= 1) this.merged = true;
    } else {
      this.mesh.position.set(f.x, 0, rawZ);
    }

    // Use recorded drift angle for body yaw
    if (f.drift !== undefined) {
      this.mesh.rotation.y = f.drift;
    } else {
      const nf = r[(this.frame + 1) % r.length];
      this.mesh.rotation.y = -(nf.x - f.x) * 0.35;
    }

    // Wheel spin + front steer from recording
    this.wheelSpin += f.speed / WHEEL_R;
    spinWheels(this.mesh, this.wheelSpin, f.wa || 0);

    this.frame = (this.frame + 1) % r.length;
  }

  getWorldXZ() { return { x: this.mesh.position.x, z: this.mesh.position.z }; }
}

const ghosts = [];


// ─────────────────────────────────────────────────────────────────────
//  OBSTACLE SYSTEM  (more frequent, min spacing enforced)
// ─────────────────────────────────────────────────────────────────────

const liveObstacles = [];

function seededRNG(seed) {
  let s = Math.abs(seed) || 1;
  return () => { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; };
}

const debrisWireMat = new THREE.MeshPhongMaterial({
  color: 0x0a0a0a, specular: 0xffffff, shininess: 220,
  wireframe: true, transparent: true, opacity: 0.45
});

function spawnObstacles(loopNum) {
  for (const o of liveObstacles) scene.remove(o.mesh);
  liveObstacles.length = 0;
  if (loopNum === 0) return;

  const rng   = seededRNG(loopNum * 6271 + 43);
  const count = Math.min(4 + Math.floor(loopNum * 1.4), 18);

  const placed = [];   // Z positions already used

  for (let i = 0; i < count; i++) {
    let ox, oz, valid;
    let attempts = 0;
    do {
      ox = (rng() - 0.5) * (ROAD_WIDTH - 2);
      oz = rng() * (ROAD_LENGTH - 80) + 40;
      valid = true;
      for (const pz of placed) {
        if (Math.abs(oz - pz) < MIN_OBS_SPACING) { valid = false; break; }
      }
      attempts++;
    } while (!valid && attempts < 40);
    if (!valid) continue;
    placed.push(oz);

    let mesh;
    if (rng() > 0.50) {
      mesh = createSedan(0x121216);
      mesh.rotation.y = (rng() - 0.5) * 0.5;
    } else {
      mesh = new THREE.Group();
      const dm = new THREE.MeshPhongMaterial({ color: 0x1c1c1c, specular: 0x555555, shininess: 18 });
      for (let j = 0; j < 7; j++) {
        const sz = 0.25 + rng() * 0.85;
        const geo = new THREE.BoxGeometry(sz, sz * 0.45, sz);
        const bx = new THREE.Mesh(geo, dm);
        bx.position.set((rng() - 0.5) * 3.0, sz * 0.22, (rng() - 0.5) * 3.0);
        bx.rotation.set(rng(), rng(), rng());
        mesh.add(bx);
        const wire = new THREE.Mesh(geo, debrisWireMat);
        wire.position.copy(bx.position); wire.rotation.copy(bx.rotation);
        wire.scale.setScalar(1.04); mesh.add(wire);
      }
    }
    scene.add(mesh);
    liveObstacles.push({ mesh, ox, oz });
  }
}


// ─────────────────────────────────────────────────────────────────────
//  GREEN ROAD SIGNS  (pooled, canvas-textured, with spot illumination)
// ─────────────────────────────────────────────────────────────────────

function makeSignCanvas() {
  const c = document.createElement('canvas');
  c.width = 512; c.height = 256;
  return c;
}

function drawSignText(ctx, line1, line2) {
  ctx.fillStyle = '#006633';
  ctx.fillRect(0, 0, 512, 256);
  ctx.strokeStyle = '#cccccc';
  ctx.lineWidth = 6;
  ctx.strokeRect(10, 10, 492, 236);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  if (line2) {
    ctx.font = 'bold 38px Arial, sans-serif';
    ctx.fillText(line1, 256, 96);
    ctx.font = '26px Arial, sans-serif';
    ctx.fillText(line2, 256, 168);
  } else {
    ctx.font = 'bold 42px Arial, sans-serif';
    ctx.fillText(line1, 256, 128);
  }
}

function createRoadSign() {
  const g = new THREE.Group();
  const poleMat = new THREE.MeshPhongMaterial({ color: 0x606060, specular: 0x444444, shininess: 20 });

  // Vertical pole
  const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.08, 5.6, 6), poleMat);
  pole.position.set(0, 2.8, 0);
  g.add(pole);

  // Horizontal arm toward road centre
  const armLen = 2.4;
  const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, armLen, 4), poleMat);
  arm.rotation.z = Math.PI / 2;
  arm.position.set(-armLen / 2, 5.4, 0);
  g.add(arm);

  // Sign panel (front face → +Z, facing oncoming car)
  const canvas = makeSignCanvas();
  const ctx = canvas.getContext('2d');
  drawSignText(ctx, '0 SOLS', '');
  const tex = new THREE.CanvasTexture(canvas);
  const signMat = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.55, metalness: 0.04 });
  const panel = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 1.4), signMat);
  panel.position.set(-armLen + 0.2, 5.4, 0);
  g.add(panel);

  // Dark back panel
  const backMat = new THREE.MeshPhongMaterial({ color: 0x1a1a1a });
  const back = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 1.4), backMat);
  back.rotation.y = Math.PI;
  back.position.set(-armLen + 0.2, 5.4, -0.02);
  g.add(back);

  // Two small spotlights illuminating sign face
  for (const ox of [-0.7, 0.7]) {
    const sLight = new THREE.SpotLight(0xffffff, 35, 5.5, Math.PI / 4.5, 0.65, 1.8);
    const tgt = new THREE.Object3D();
    tgt.position.set(-armLen + 0.2 + ox, 5.1, 0);
    sLight.position.set(-armLen + 0.2 + ox, 6.4, -0.35);
    sLight.target = tgt;
    g.add(sLight); g.add(tgt);
    // Small fixture housing
    const fix = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.06, 0.16),
      new THREE.MeshPhongMaterial({ color: 0x222222 }));
    fix.position.set(-armLen + 0.2 + ox, 6.35, -0.3);
    g.add(fix);
  }

  g.userData.canvas = canvas;
  g.userData.ctx = ctx;
  g.userData.texture = tex;
  g.userData.line1 = '';
  g.userData.line2 = '';
  g.userData.text = '';
  return g;
}

const roadSigns = [];
for (let i = 0; i < NUM_SIGN_SLOTS; i++) {
  const s = createRoadSign();
  scene.add(s);
  roadSigns.push(s);
}

function getSignContent(idx) {
  const type = ((idx % 5) + 5) % 5;
  switch (type) {
    case 0: return { l1: Math.floor(progress / 10) + ' SOLS', l2: '' };
    case 1: return { l1: ghosts.length + (ghosts.length === 1 ? ' GHOST' : ' GHOSTS'), l2: 'ACTIVE ON ROAD' };
    case 2: return { l1: 'LOOP ' + loopCount, l2: Math.floor(progress / 10) + ' SOLS' };
    case 3: return { l1: 'NO EXIT', l2: ghosts.length + ' GHOSTS' };
    case 4: return { l1: Math.floor(progress / 10) + ' SOLS', l2: ghosts.length + ' ECHOES BEHIND' };
  }
}

function updateSignTexture(sign, l1, l2) {
  if (sign.userData.line1 === l1 && sign.userData.line2 === l2) return;
  sign.userData.line1 = l1;
  sign.userData.line2 = l2;
  sign.userData.text = l2 ? (l1 + '  —  ' + l2) : l1;
  drawSignText(sign.userData.ctx, l1, l2);
  sign.userData.texture.needsUpdate = true;
}

function updateSigns(prog) {
  const base = Math.floor(prog / SIGN_SPACING) - 1;
  const signX = ROAD_WIDTH / 2 + 2.5;
  for (let i = 0; i < NUM_SIGN_SLOTS; i++) {
    const idx = base + i;
    const z = idx * SIGN_SPACING;
    roadSigns[i].position.set(signX, 0, -z);
    const content = getSignContent(idx);
    updateSignTexture(roadSigns[i], content.l1, content.l2);
  }
}


// ─────────────────────────────────────────────────────────────────────
//  STREET LAMP FLICKER
// ─────────────────────────────────────────────────────────────────────

const lampFlickerState = [];
for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
  lampFlickerState.push({ active: false, timer: 0, seed: Math.random() * 1000 });
}

function updateLampFlicker() {
  for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
    const fs = lampFlickerState[i];
    if (!fs.active) {
      if (Math.random() < 0.0015) {
        fs.active = true;
        fs.timer = 25 + Math.floor(Math.random() * 70);
      }
      lampSpots[i].intensity = 380;
    } else {
      fs.timer--;
      const flick = Math.sin(fs.timer * 0.9 + fs.seed) * Math.sin(fs.timer * 2.3);
      lampSpots[i].intensity = flick > 0.05 ? 380 : 15;
      // Also dim the glass glow on the lamp post
      if (fs.timer <= 0) {
        fs.active = false;
        lampSpots[i].intensity = 380;
      }
    }
  }
}


// ─────────────────────────────────────────────────────────────────────
//  RAIN
// ─────────────────────────────────────────────────────────────────────

const rainGeo = new THREE.BufferGeometry();
const rainPos = new Float32Array(RAIN_COUNT * 6);
const rainVel = new Float32Array(RAIN_COUNT);

for (let i = 0; i < RAIN_COUNT; i++) {
  const x = (Math.random() - 0.5) * RAIN_SPREAD;
  const y = Math.random() * RAIN_HEIGHT;
  const z = (Math.random() - 0.5) * RAIN_SPREAD;
  rainVel[i] = 0.30 + Math.random() * 0.35;
  const b = i * 6;
  rainPos[b] = x; rainPos[b+1] = y; rainPos[b+2] = z;
  rainPos[b+3] = x + 0.012; rainPos[b+4] = y - STREAK_LEN; rainPos[b+5] = z - 0.006;
}
rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));
const rainMat = new THREE.LineBasicMaterial({ color: 0x8899aa, transparent: true, opacity: 0.30, depthWrite: false });
const rainMesh = new THREE.LineSegments(rainGeo, rainMat);
scene.add(rainMesh);

function tickRain(anchor) {
  const p = rainGeo.attributes.position.array;
  for (let i = 0; i < RAIN_COUNT; i++) {
    const b = i * 6, v = rainVel[i];
    p[b+1] -= v; p[b+4] -= v;
    p[b] += 0.018; p[b+3] += 0.018;
    p[b+2] -= 0.009; p[b+5] -= 0.009;
    if (p[b+1] < -0.5) {
      const x = (Math.random()-0.5)*RAIN_SPREAD, y = RAIN_HEIGHT+Math.random()*3, z = (Math.random()-0.5)*RAIN_SPREAD;
      p[b]=x; p[b+1]=y; p[b+2]=z; p[b+3]=x+0.012; p[b+4]=y-STREAK_LEN; p[b+5]=z-0.006;
    }
  }
  rainMesh.position.copy(anchor);
  rainGeo.attributes.position.needsUpdate = true;
}


// ─────────────────────────────────────────────────────────────────────
//  DYNAMIC CAMERA  (reacts to drift angle)
// ─────────────────────────────────────────────────────────────────────

let camRoll      = 0;
let camFov       = 66;
let smoothSteer  = 0;
const _lookTarget = new THREE.Vector3(0, 0.9, -22);
let   _lookInit   = false;

function updateCamera(carPos, spd, rawSteer, drift) {
  const sf = spd / MAX_SPEED;

  smoothSteer += (rawSteer - smoothSteer) * 0.04;

  camLagX += (carPos.x - camLagX) * 0.022;

  // Lean from drift angle (camera pulls to outside of drift)
  const lean = drift * 0.22;

  const ix = camLagX * 0.36 + lean;
  const iy = 2.15 + sf * 0.42 + Math.abs(drift) * 0.10;
  const iz = carPos.z + 4.2 + sf * 1.8;

  camera.position.x += (ix - camera.position.x) * 0.024;
  camera.position.y += (iy - camera.position.y) * 0.022;
  camera.position.z += (iz - camera.position.z) * 0.030;

  const la     = 20 + sf * 14;
  const wantLX = carPos.x * 0.46 + lean * 0.20;
  const wantLY = 0.85;
  const wantLZ = carPos.z - la;

  if (!_lookInit) { _lookTarget.set(wantLX, wantLY, wantLZ); _lookInit = true; }
  _lookTarget.x += (wantLX - _lookTarget.x) * 0.028;
  _lookTarget.y += (wantLY - _lookTarget.y) * 0.028;
  _lookTarget.z += (wantLZ - _lookTarget.z) * 0.042;
  camera.lookAt(_lookTarget);

  // Roll with drift
  const tr = -drift * 0.15;
  camRoll += (tr - camRoll) * 0.020;
  camera.rotation.z = camRoll;

  const tf = 64 + sf * 10;
  camFov += (tf - camFov) * 0.016;
  camera.fov = camFov;
  camera.updateProjectionMatrix();
}


// ─────────────────────────────────────────────────────────────────────
//  INPUT
// ─────────────────────────────────────────────────────────────────────

const keys = {};
window.addEventListener('keydown', e => {
  keys[e.code] = true;
  if (e.code === 'KeyP' && !e.repeat) togglePause();
  if (e.code === 'KeyR' && crashed) restartGame();
});
window.addEventListener('keyup', e => { keys[e.code] = false; });


// ─────────────────────────────────────────────────────────────────────
//  GAME STATE
// ─────────────────────────────────────────────────────────────────────

let loopCount = 0, lastLoopIdx = 0, paused = false, crashed = false;
const crashOverlay = document.getElementById('crash-overlay');
const crashSolsEl  = crashOverlay.querySelector('.sols-final');
const solsEl       = document.getElementById('sols');

function togglePause() { if (!crashed) paused = !paused; }

function boxesOverlap(ax, az, bx, bz, hx, hz) {
  return Math.abs(ax - bx) < hx * 2 && Math.abs(az - bz) < hz * 2;
}

function triggerCrash() {
  if (crashed) return;
  crashed = true;
  crashSolsEl.textContent = Math.floor(progress / 10) + ' sols traveled';
  crashOverlay.classList.add('active');
}

function restartGame() {
  crashed = false;
  crashOverlay.classList.remove('active');
  for (const gh of ghosts) scene.remove(gh.mesh);
  ghosts.length = 0; allRecordings.length = 0; currentRecording = [];
  progress = 0; currentX = 0; camLagX = 0;
  speed = BASE_SPEED; prevSpeed = BASE_SPEED; steer = 0;
  carPitch = 0; playerWheelSpin = 0; smoothSteer = 0;
  driftAngle = 0; driftVel = 0; lateralVel = 0;
  loopCount = 0; lastLoopIdx = 0;
  _lookInit = false; camRoll = 0; camFov = 66;
  spawnObstacles(0); solsEl.textContent = '0 sols';
  solsEl.classList.remove('sign-mode');
}

function lerp(a, b, t) { return a + (b - a) * t; }


// ═══════════════════════════════════════════════════════════════════════
//  MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════

let lastT = 0;
spawnObstacles(0);

function frame(ts) {
  requestAnimationFrame(frame);
  const dt = Math.min((ts - lastT) / 1000, 0.05);
  lastT = ts;

  if (paused || crashed) { renderer.render(scene, camera); return; }

  // ── Input ────────────────────────────────────────────────────
  steer = 0;
  if (keys['ArrowLeft'] || keys['KeyA']) steer -= 1;
  if (keys['ArrowRight'] || keys['KeyD']) steer += 1;

  prevSpeed = speed;
  if (keys['ArrowUp'] || keys['KeyW'])        speed = Math.min(MAX_SPEED, speed + ACCEL);
  else if (keys['ArrowDown'] || keys['KeyS']) speed = Math.max(MIN_SPEED, speed - BRAKE);
  else {
    if (speed > BASE_SPEED)      speed = Math.max(BASE_SPEED, speed - DRAG);
    else if (speed < BASE_SPEED) speed = Math.min(BASE_SPEED, speed + DRAG * 0.4);
  }

  // ── Drift physics (sign-corrected) ──────────────────────────
  driftVel -= steer * DRIFT_STEER * (0.5 + speed * 0.7);
  driftVel *= DRIFT_DAMP;
  driftAngle += driftVel;
  driftAngle *= (1 - DRIFT_GRIP);

  lateralVel -= Math.sin(driftAngle) * speed * DRIFT_SLIDE;
  lateralVel *= DRIFT_FRICTION;

  currentX += lateralVel;
  currentX = Math.max(-MAX_LATERAL, Math.min(MAX_LATERAL, currentX));

  progress += speed;

  // ── Wheels ──────────────────────────────────────────────────
  playerWheelSpin += speed / WHEEL_R;
  const frontWheelAngle = steer * 0.38 + driftAngle * 0.15;
  spinWheels(playerCar, playerWheelSpin, frontWheelAngle);

  // ── Record ──────────────────────────────────────────────────
  currentRecording.push({
    x: currentX, z: progress % ROAD_LENGTH, speed,
    drift: driftAngle, wa: frontWheelAngle
  });

  // ── Loop detection ──────────────────────────────────────────
  const curLoop = Math.floor(progress / ROAD_LENGTH);
  if (curLoop > lastLoopIdx) {
    loopCount++; lastLoopIdx = curLoop;
    if (currentRecording.length > 0) {
      allRecordings.push([...currentRecording]);
      ghosts.push(new Ghost(allRecordings[allRecordings.length - 1]));
      currentRecording = [];
    }
    spawnObstacles(loopCount);
  }

  // ── Positioning ─────────────────────────────────────────────
  const baseZ = curLoop * ROAD_LENGTH;

  playerCar.position.set(currentX, 0, -progress);
  playerCar.rotation.y = driftAngle;

  const accel = speed - prevSpeed;
  carPitch = lerp(carPitch, accel * 2.5, 0.10);
  playerCar.rotation.x = carPitch;

  // Headlights — target very far ahead
  hlL.position.set(currentX - 0.56, 0.54, -progress - 2.4);
  hlR.position.set(currentX + 0.56, 0.54, -progress - 2.4);
  hlL.target.position.set(currentX - 1.8, -0.15, -progress - 340);
  hlR.target.position.set(currentX + 1.8, -0.15, -progress - 340);
  tailGlow.position.set(currentX, 0.54, -progress + 2.5);

  // ── Road tiling ─────────────────────────────────────────────
  const si = Math.floor(progress / ROAD_LENGTH);
  for (let i = 0; i < 3; i++) segments[i].position.z = -(si - 1 + i) * ROAD_LENGTH;

  // ── Lamps + flicker ─────────────────────────────────────────
  updateLamps(progress);
  updateLampFlicker();

  // ── Ghosts + collision ──────────────────────────────────────
  const pWZ = -progress;
  for (const gh of ghosts) {
    gh.update(baseZ);
    if (gh.merged) {
      const gp = gh.getWorldXZ();
      if (boxesOverlap(currentX, pWZ, gp.x, gp.z, COL_HX, COL_HZ)) { triggerCrash(); break; }
    }
  }

  // ── Obstacles + collision ───────────────────────────────────
  for (const ob of liveObstacles) {
    ob.mesh.position.z = -(baseZ + ob.oz);
    ob.mesh.position.x = ob.ox;
    if (boxesOverlap(currentX, pWZ, ob.ox, ob.mesh.position.z, COL_HX, COL_HZ)) triggerCrash();
  }

  // ── Road signs ──────────────────────────────────────────────
  updateSigns(progress);

  // ── Rain ────────────────────────────────────────────────────
  tickRain(playerCar.position);

  // ── Sols / sign overlay ────────────────────────────────────
  let nearSign = false;
  for (let si2 = 0; si2 < NUM_SIGN_SLOTS; si2++) {
    const sz = roadSigns[si2].position.z;
    const dist = Math.abs(sz - (-progress));
    if (dist < 35) {
      nearSign = true;
      solsEl.textContent = roadSigns[si2].userData.text || Math.floor(progress / 10) + ' sols';
      if (!solsEl.classList.contains('sign-mode')) solsEl.classList.add('sign-mode');
      break;
    }
  }
  if (!nearSign) {
    solsEl.textContent = Math.floor(progress / 10) + ' sols';
    if (solsEl.classList.contains('sign-mode')) solsEl.classList.remove('sign-mode');
  }

  // ── Camera ──────────────────────────────────────────────────
  updateCamera(playerCar.position, speed, steer, driftAngle);

  // ── Render: main view ───────────────────────────────────────
  renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
  renderer.render(scene, camera);

  // ── Render: rearview mirror ─────────────────────────────────
  const mRect = mirrorEl.getBoundingClientRect();
  const mvX = Math.round(mRect.left);
  const mvY = Math.round(window.innerHeight - mRect.bottom);
  const mvW = Math.round(mRect.width);
  const mvH = Math.round(mRect.height);

  if (mvW > 0 && mvH > 0) {
    // Position mirror camera at roof level, looking backward
    mirrorCam.position.set(currentX, 1.28, -progress + 0.2);
    mirrorCam.lookAt(currentX + driftAngle * 2.0, 0.85, -progress + 120);

    // Slightly less fog for mirror so headlights behind are more visible
    const origFog = scene.fog.density;
    scene.fog.density = FOG_DENSITY * 0.45;

    renderer.clearDepth();
    renderer.setViewport(mvX, mvY, mvW, mvH);
    renderer.setScissor(mvX, mvY, mvW, mvH);
    renderer.setScissorTest(true);
    renderer.render(scene, mirrorCam);
    renderer.setScissorTest(false);

    scene.fog.density = origFog;
    renderer.setViewport(0, 0, window.innerWidth, window.innerHeight);
  }
}

requestAnimationFrame(frame);
</script>
</body>
</html>
