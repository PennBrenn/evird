<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Empty Freeway</title>
<style>
  *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { width: 100%; height: 100%; overflow: hidden; background: #000; cursor: none; }
  canvas { display: block; }

  /* ── Crash Overlay ──────────────────────────────────────── */
  #crash-overlay {
    position: fixed; inset: 0; z-index: 100;
    display: flex; align-items: center; justify-content: center;
    background: rgba(0, 0, 0, 0);
    pointer-events: none;
    transition: background 1.2s ease;
    font-family: 'Courier New', monospace;
  }
  #crash-overlay.active {
    background: rgba(0, 0, 0, 0.82);
  }
  #crash-overlay .msg {
    color: #887766;
    font-size: 18px;
    letter-spacing: 8px;
    text-transform: uppercase;
    opacity: 0;
    transform: translateY(8px);
    transition: opacity 1.4s ease 0.6s, transform 1.4s ease 0.6s;
  }
  #crash-overlay.active .msg {
    opacity: 1;
    transform: translateY(0);
  }

  /* ── Pause Overlay ──────────────────────────────────────── */
  #pause-overlay {
    position: fixed; inset: 0; z-index: 90;
    display: none; align-items: center; justify-content: center;
    background: rgba(0, 0, 0, 0.55);
    pointer-events: none;
    font-family: 'Courier New', monospace;
  }
  #pause-overlay.active {
    display: flex;
  }
  #pause-overlay .msg {
    color: #665e55;
    font-size: 14px;
    letter-spacing: 10px;
    text-transform: uppercase;
  }
</style>
</head>
<body>

<!-- Crash screen (hidden until collision) -->
<div id="crash-overlay"><span class="msg">Timeline Fractured</span></div>

<!-- Pause screen (hidden until P pressed) -->
<div id="pause-overlay"><span class="msg">Paused</span></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  THE EMPTY FREEWAY — Endless Loop Driving Simulation
// ═══════════════════════════════════════════════════════════════════════
//
//  Refined build: interpolated steering, ghost collision, pause,
//  enhanced lighting. The road remembers. The road forgives nothing.
//
// ═══════════════════════════════════════════════════════════════════════


// ─────────────────────────────────────────────────────────────────────
//  CONSTANTS
// ─────────────────────────────────────────────────────────────────────

const ROAD_LENGTH     = 1000;
const ROAD_WIDTH      = 14;
const LANE_WIDTH      = 3.5;
const SHOULDER_EXTRA  = 3;

const LAMP_SPACING    = 50;
const LAMP_HEIGHT     = 9;
const LAMP_ARM_REACH  = 3.5;
const NUM_LAMP_SLOTS  = 12;

const FOG_DENSITY     = 0.014;

const BASE_SPEED      = 0.45;
const MAX_SPEED       = 1.4;
const MIN_SPEED       = 0.08;
const ACCEL           = 0.007;
const BRAKE           = 0.014;
const DRAG            = 0.0015;

// ── Interpolated steering ─────────────────────────────────────────
// Instead of instant lateral movement, the player sets a targetX
// and the car's actual position lerps toward it each frame.
const STEER_RATE      = 0.13;       // how fast targetX shifts per frame
const STEER_LERP      = 0.045;      // how fast currentX chases targetX (lower = floatier)
const MAX_LATERAL     = 6.5;

// Ghost merge
const MERGE_FRAMES    = 420;
const MERGE_START_Y   = -3.5;
const MERGE_START_Z   = 30;

// Collision (AABB half-extents for the sedan shape)
const CAR_HALF_W      = 0.94;       // ~half of 1.88 chassis width
const CAR_HALF_L      = 2.40;       // ~half of 4.8 bumper-to-bumper length
const CAR_HALF_H      = 0.70;       // vertical extent (roof at ~1.4, ground at 0)
const CRASH_RESET_MS  = 3000;       // delay before loop restarts after crash

// Rain
const RAIN_COUNT      = 5000;
const RAIN_SPREAD     = 70;
const RAIN_HEIGHT     = 25;


// ─────────────────────────────────────────────────────────────────────
//  RENDERER, SCENE, CAMERA
// ─────────────────────────────────────────────────────────────────────

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping            = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure    = 0.75;              // ↑ from 0.65 — more legible
renderer.physicallyCorrectLights = true;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, FOG_DENSITY);

const camera = new THREE.PerspectiveCamera(
  66, window.innerWidth / window.innerHeight, 0.1, 600
);

// Ambient bumped up: still dark and liminal, but asphalt detail is legible
scene.add(new THREE.AmbientLight(0x14141e, 0.28));

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});


// ─────────────────────────────────────────────────────────────────────
//  ROAD SYSTEM
// ─────────────────────────────────────────────────────────────────────

const asphaltMat = new THREE.MeshStandardMaterial({
  color: 0x1c1c1c, roughness: 0.18, metalness: 0.05
});
const shoulderMat = new THREE.MeshStandardMaterial({
  color: 0x111111, roughness: 0.45, metalness: 0.0
});
const markingMat = new THREE.MeshStandardMaterial({
  color: 0x55554a, roughness: 0.30, emissive: 0x0a0a08, emissiveIntensity: 0.1
});
const railMat = new THREE.MeshPhongMaterial({
  color: 0x303030, specular: 0x444444, shininess: 25
});
const medianMat = new THREE.MeshStandardMaterial({
  color: 0x222222, roughness: 0.6, metalness: 0.0
});

function createRoadSegment() {
  const g = new THREE.Group();

  const roadGeo = new THREE.PlaneGeometry(ROAD_WIDTH, ROAD_LENGTH, 1, 1);
  const road = new THREE.Mesh(roadGeo, asphaltMat);
  road.rotation.x = -Math.PI / 2;
  road.position.set(0, 0, -ROAD_LENGTH / 2);
  g.add(road);

  const shGeo = new THREE.PlaneGeometry(ROAD_WIDTH + SHOULDER_EXTRA * 2, ROAD_LENGTH, 1, 1);
  const sh = new THREE.Mesh(shGeo, shoulderMat);
  sh.rotation.x = -Math.PI / 2;
  sh.position.set(0, -0.015, -ROAD_LENGTH / 2);
  g.add(sh);

  // Dashed lane dividers (dividers at x = ±1.75)
  const dashLen = 4, gapLen = 7;
  const cycle  = dashLen + gapLen;
  const nDash  = Math.ceil(ROAD_LENGTH / cycle);
  const dashGeo = new THREE.PlaneGeometry(0.13, dashLen);

  for (const lx of [-LANE_WIDTH / 2, LANE_WIDTH / 2]) {
    for (let i = 0; i < nDash; i++) {
      const d = new THREE.Mesh(dashGeo, markingMat);
      d.rotation.x = -Math.PI / 2;
      d.position.set(lx, 0.006, -(i * cycle + dashLen / 2));
      g.add(d);
    }
  }

  // Solid edge lines
  const edgeGeo = new THREE.PlaneGeometry(0.14, ROAD_LENGTH);
  for (const sx of [-1, 1]) {
    const e = new THREE.Mesh(edgeGeo, markingMat);
    e.rotation.x = -Math.PI / 2;
    e.position.set(sx * (ROAD_WIDTH / 2 - 0.5), 0.006, -ROAD_LENGTH / 2);
    g.add(e);
  }

  // Guardrails
  const gRailGeo = new THREE.BoxGeometry(0.07, 0.7, ROAD_LENGTH);
  for (const sx of [-1, 1]) {
    const r = new THREE.Mesh(gRailGeo, railMat);
    r.position.set(sx * (ROAD_WIDTH / 2 + 2), 0.35, -ROAD_LENGTH / 2);
    g.add(r);
    const r2 = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.08, ROAD_LENGTH), railMat
    );
    r2.position.set(sx * (ROAD_WIDTH / 2 + 2), 0.08, -ROAD_LENGTH / 2);
    g.add(r2);
  }

  // Median
  const medGeo = new THREE.BoxGeometry(0.6, 0.35, ROAD_LENGTH);
  const med = new THREE.Mesh(medGeo, medianMat);
  med.position.set(-(ROAD_WIDTH / 2 + 3.0), 0.17, -ROAD_LENGTH / 2);
  g.add(med);

  return g;
}

const segments = [createRoadSegment(), createRoadSegment(), createRoadSegment()];
segments.forEach(s => scene.add(s));


// ─────────────────────────────────────────────────────────────────────
//  STREET LAMP SYSTEM (wider attenuation for overlapping light pools)
// ─────────────────────────────────────────────────────────────────────

const lampPostMat = new THREE.MeshPhongMaterial({
  color: 0x252525, specular: 0x333333, shininess: 15
});
const lampGlassMat = new THREE.MeshBasicMaterial({
  color: 0xffe8c0, transparent: true, opacity: 0.75
});

function createLampPost() {
  const g = new THREE.Group();

  const pole = new THREE.Mesh(
    new THREE.CylinderGeometry(0.075, 0.10, LAMP_HEIGHT, 6), lampPostMat
  );
  pole.position.y = LAMP_HEIGHT / 2;
  g.add(pole);

  const arm = new THREE.Mesh(
    new THREE.CylinderGeometry(0.04, 0.04, LAMP_ARM_REACH, 4), lampPostMat
  );
  arm.rotation.z = Math.PI / 2;
  arm.position.set(-LAMP_ARM_REACH / 2, LAMP_HEIGHT - 0.15, 0);
  g.add(arm);

  const housing = new THREE.Mesh(
    new THREE.BoxGeometry(0.45, 0.12, 0.75),
    new THREE.MeshPhongMaterial({ color: 0x1a1a1a })
  );
  housing.position.set(-LAMP_ARM_REACH, LAMP_HEIGHT - 0.22, 0);
  g.add(housing);

  const glass = new THREE.Mesh(
    new THREE.PlaneGeometry(0.38, 0.65), lampGlassMat
  );
  glass.rotation.x = -Math.PI / 2;
  glass.position.set(-LAMP_ARM_REACH, LAMP_HEIGHT - 0.29, 0);
  g.add(glass);

  const base = new THREE.Mesh(
    new THREE.CylinderGeometry(0.18, 0.22, 0.12, 6), lampPostMat
  );
  base.position.y = 0.06;
  g.add(base);

  return g;
}

const lampPosts = [];
const lampSpots = [];

for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
  const post = createLampPost();
  scene.add(post);
  lampPosts.push(post);

  // Wider cone, longer distance, lower decay → light pools overlap
  const spot = new THREE.SpotLight(
    0xffe0a0,        // warm sodium-vapor
    400,             // ↑ intensity (from 300)
    95,              // ↑ distance (from 65) — pools now overlap
    Math.PI / 2.8,   // ↑ wider cone angle (from PI/3.2)
    0.82,            // penumbra
    1.6              // ↓ decay (from 2) — gentler falloff
  );
  spot.target = new THREE.Object3D();
  scene.add(spot);
  scene.add(spot.target);
  lampSpots.push(spot);
}

function updateLamps(prog) {
  const base = Math.floor(prog / LAMP_SPACING) - 3;
  for (let i = 0; i < NUM_LAMP_SLOTS; i++) {
    const idx    = base + i;
    const z      = idx * LAMP_SPACING;
    const side   = (idx % 2 === 0) ? 1 : -1;
    const postX  = side * (ROAD_WIDTH / 2 + 2);
    const lightX = side * (ROAD_WIDTH / 2 - 1);

    lampPosts[i].position.set(postX, 0, -z);
    lampPosts[i].scale.x = side;

    lampSpots[i].position.set(lightX, LAMP_HEIGHT, -z);
    lampSpots[i].target.position.set(lightX * 0.3, 0, -z);
  }
}


// ─────────────────────────────────────────────────────────────────────
//  SEDAN MODEL
// ─────────────────────────────────────────────────────────────────────

function createSedan(colour) {
  const g = new THREE.Group();

  const body = new THREE.MeshPhongMaterial({
    color: colour, specular: 0x555555, shininess: 95, flatShading: false
  });
  const glass = new THREE.MeshPhongMaterial({
    color: 0x080812, specular: 0x999999, shininess: 130,
    transparent: true, opacity: 0.65
  });
  const trim = new THREE.MeshPhongMaterial({
    color: 0x0f0f0f, specular: 0x333333, shininess: 30
  });
  const rubber = new THREE.MeshPhongMaterial({
    color: 0x0a0a0a, specular: 0x111111, shininess: 8
  });

  // Chassis
  const chassis = new THREE.Mesh(new THREE.BoxGeometry(1.88, 0.42, 4.7), body);
  chassis.position.y = 0.44;
  g.add(chassis);

  // Hood
  const hood = new THREE.Mesh(new THREE.BoxGeometry(1.78, 0.16, 1.35), body);
  hood.position.set(0, 0.74, -1.30);
  g.add(hood);

  // Cabin
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(1.62, 0.52, 2.0), body);
  cabin.position.set(0, 1.10, 0.05);
  g.add(cabin);

  // Trunk
  const trunk = new THREE.Mesh(new THREE.BoxGeometry(1.78, 0.14, 1.15), body);
  trunk.position.set(0, 0.73, 1.42);
  g.add(trunk);

  // Windshield
  const ws = new THREE.Mesh(new THREE.BoxGeometry(1.52, 0.50, 0.04), glass);
  ws.rotation.x = 0.38;
  ws.position.set(0, 1.04, -0.92);
  g.add(ws);

  // Rear window
  const rw = new THREE.Mesh(new THREE.BoxGeometry(1.48, 0.44, 0.04), glass);
  rw.rotation.x = -0.42;
  rw.position.set(0, 1.02, 1.02);
  g.add(rw);

  // Side windows
  for (const s of [-1, 1]) {
    const sw = new THREE.Mesh(new THREE.BoxGeometry(0.04, 0.34, 1.55), glass);
    sw.position.set(s * 0.82, 1.10, 0.05);
    g.add(sw);
  }

  // Roof
  const roof = new THREE.Mesh(new THREE.BoxGeometry(1.56, 0.035, 1.75), trim);
  roof.position.set(0, 1.375, 0.05);
  g.add(roof);

  // Bumpers
  const bGeo = new THREE.BoxGeometry(1.92, 0.22, 0.16);
  g.add(Object.assign(new THREE.Mesh(bGeo, trim), { position: new THREE.Vector3(0, 0.33, -2.40) }));
  g.add(Object.assign(new THREE.Mesh(bGeo, trim), { position: new THREE.Vector3(0, 0.33, 2.40) }));

  // Wheels
  const wheelGeo = new THREE.CylinderGeometry(0.32, 0.32, 0.22, 14);
  const rimGeo   = new THREE.CylinderGeometry(0.20, 0.20, 0.24, 10);
  const rimMat   = new THREE.MeshPhongMaterial({
    color: 0x2a2a2a, specular: 0x777777, shininess: 55
  });
  for (const [wx, wy, wz] of [
    [-0.88, 0.32, -1.35], [0.88, 0.32, -1.35],
    [-0.88, 0.32,  1.35], [0.88, 0.32,  1.35]
  ]) {
    const wheel = new THREE.Mesh(wheelGeo, rubber);
    wheel.rotation.z = Math.PI / 2;
    wheel.position.set(wx, wy, wz);
    g.add(wheel);
    const rim = new THREE.Mesh(rimGeo, rimMat);
    rim.rotation.z = Math.PI / 2;
    rim.position.set(wx, wy, wz);
    g.add(rim);
  }

  // Headlights
  const hlMat = new THREE.MeshBasicMaterial({ color: 0xfff4e0 });
  for (const sx of [-0.62, 0.62]) {
    const hl = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.14, 0.07), hlMat);
    hl.position.set(sx, 0.54, -2.38);
    g.add(hl);
  }

  // Taillights
  const tlMat = new THREE.MeshBasicMaterial({ color: 0x880000 });
  for (const sx of [-0.62, 0.62]) {
    const tl = new THREE.Mesh(new THREE.BoxGeometry(0.30, 0.11, 0.06), tlMat);
    tl.position.set(sx, 0.54, 2.38);
    g.add(tl);
  }

  // Side mirrors
  for (const s of [-1, 1]) {
    const mir = new THREE.Mesh(new THREE.BoxGeometry(0.14, 0.08, 0.10), trim);
    mir.position.set(s * 0.98, 0.88, -0.60);
    g.add(mir);
  }

  return g;
}


// ─────────────────────────────────────────────────────────────────────
//  PLAYER
// ─────────────────────────────────────────────────────────────────────

const playerCar = createSedan(0x1e1e28);
scene.add(playerCar);

function makeHeadlight() {
  const sl = new THREE.SpotLight(0xfff2da, 180, 90, Math.PI / 7.5, 0.55, 2);
  sl.target = new THREE.Object3D();
  scene.add(sl);
  scene.add(sl.target);
  return sl;
}
const hlL = makeHeadlight();
const hlR = makeHeadlight();

const tailGlow = new THREE.PointLight(0x880000, 8, 10, 2);
scene.add(tailGlow);

// ── Player state ──────────────────────────────────────────────────
let progress   = 0;            // cumulative distance (never wraps)
let targetX    = 0;            // where the player WANTS to be laterally
let currentX   = 0;            // where the car ACTUALLY is (lerps toward targetX)
let speed      = BASE_SPEED;
let prevSpeed  = BASE_SPEED;
let steer      = 0;            // raw input this frame (-1, 0, 1)
let carPitch   = 0;


// ─────────────────────────────────────────────────────────────────────
//  GHOST SYSTEM — "The Ascending"
// ─────────────────────────────────────────────────────────────────────

const allRecordings    = [];
let   currentRecording = [];

class Ghost {
  constructor(recording) {
    this.rec    = recording;
    this.mesh   = createSedan(0x1e1e28);   // identical to player
    this.frame  = 0;
    this.mFrame = 0;
    this.merged = false;
    this.mesh.visible = true;
    scene.add(this.mesh);
  }

  static ease(t) { return t * t * (3 - 2 * t); }

  update(loopBaseZ) {
    const r = this.rec;
    if (!r.length) return;

    const f    = r[this.frame % r.length];
    const rawZ = -(loopBaseZ + f.z);

    if (!this.merged) {
      this.mFrame++;
      const t = Math.min(this.mFrame / MERGE_FRAMES, 1);
      const s = Ghost.ease(t);
      const yOff = MERGE_START_Y * (1 - s);
      const zOff = MERGE_START_Z * (1 - s);
      this.mesh.position.set(f.x, yOff, rawZ + zOff);
      if (t >= 1) this.merged = true;
    } else {
      this.mesh.position.set(f.x, 0, rawZ);
    }

    const nf = r[(this.frame + 1) % r.length];
    this.mesh.rotation.y = -(nf.x - f.x) * 0.35;
    this.frame = (this.frame + 1) % r.length;
  }

  /**
   * World-space AABB center: this.mesh.position (x, y, z).
   * Half-extents: CAR_HALF_W (x), CAR_HALF_L (z), CAR_HALF_H (y).
   * Returns true if this ghost's box overlaps the player's.
   */
  overlapsPlayer(playerWorldX, playerWorldY, playerWorldZ) {
    // Only test merged ghosts (can't crash into one still rising)
    if (!this.merged) return false;

    const gx = this.mesh.position.x;
    const gy = this.mesh.position.y;
    const gz = this.mesh.position.z;

    const dx = Math.abs(gx - playerWorldX);
    const dy = Math.abs(gy - playerWorldY);
    const dz = Math.abs(gz - playerWorldZ);

    // Full 3D AABB overlap: check all three axes
    return dx < CAR_HALF_W * 2 && dy < CAR_HALF_H * 2 && dz < CAR_HALF_L * 2;
  }
}

const ghosts = [];


// ─────────────────────────────────────────────────────────────────────
//  CRASH STATE
// ─────────────────────────────────────────────────────────────────────

const crashOverlay = document.getElementById('crash-overlay');
let crashed      = false;
let crashTimer   = 0;

/**
 * Trigger the crash sequence: freeze movement, dim screen,
 * show "Timeline Fractured", then reset after CRASH_RESET_MS.
 */
function triggerCrash() {
  if (crashed) return;
  crashed = true;
  crashOverlay.classList.add('active');

  crashTimer = setTimeout(() => {
    resetSimulation();
  }, CRASH_RESET_MS);
}

/**
 * Full reset: clear ghosts, recordings, obstacles, rewind position.
 */
function resetSimulation() {
  // Remove crash overlay
  crashOverlay.classList.remove('active');
  crashed = false;

  // Clear pause state (if player crashed while paused)
  if (paused) {
    paused = falseA;
    pauseOverlay.classList.remove('active');
  }

  // Remove all ghost meshes from scene
  for (const gh of ghosts) scene.remove(gh.mesh);
  ghosts.length = 0;
  allRecordings.length = 0;
  currentRecording = [];

  // Remove obstacles
  for (const o of liveObstacles) scene.remove(o.mesh);
  liveObstacles.length = 0;

  // Reset player state
  progress   = 0;
  targetX    = 0;
  currentX   = 0;
  speed      = BASE_SPEED;
  prevSpeed  = BASE_SPEED;
  steer      = 0;
  carPitch   = 0;
  loopCount  = 0;
  lastLoopIdx = 0;

  spawnObstacles(0);
}


// ─────────────────────────────────────────────────────────────────────
//  PAUSE STATE
// ─────────────────────────────────────────────────────────────────────

const pauseOverlay = document.getElementById('pause-overlay');
let paused = false;


// ─────────────────────────────────────────────────────────────────────
//  OBSTACLE SYSTEM — Procedural Desync
// ─────────────────────────────────────────────────────────────────────

const liveObstacles = [];

function seededRNG(seed) {
  let s = Math.abs(seed) || 1;
  return () => { s = (s * 16807) % 2147483647; return (s - 1) / 2147483646; };
}

function spawnObstacles(loopNum) {
  for (const o of liveObstacles) scene.remove(o.mesh);
  liveObstacles.length = 0;
  if (loopNum === 0) return;

  const rng   = seededRNG(loopNum * 6271 + 43);
  const count = Math.min(2 + Math.floor(loopNum * 0.6), 7);

  for (let i = 0; i < count; i++) {
    const ox = (rng() - 0.5) * (ROAD_WIDTH - 3);
    const oz = rng() * (ROAD_LENGTH - 120) + 60;

    let mesh;
    if (rng() > 0.45) {
      mesh = createSedan(0x121216);
      mesh.rotation.y = (rng() - 0.5) * 0.5;
    } else {
      mesh = new THREE.Group();
      const dm = new THREE.MeshPhongMaterial({
        color: 0x181818, specular: 0x1a1a1a, shininess: 8
      });
      for (let j = 0; j < 6; j++) {
        const sz = 0.15 + rng() * 0.7;
        const bx = new THREE.Mesh(new THREE.BoxGeometry(sz, sz * 0.4, sz), dm);
        bx.position.set((rng() - 0.5) * 2.5, sz * 0.2, (rng() - 0.5) * 2.5);
        bx.rotation.set(rng(), rng(), rng());
        mesh.add(bx);
      }
    }

    scene.add(mesh);
    liveObstacles.push({ mesh, ox, oz });
  }
}


// ─────────────────────────────────────────────────────────────────────
//  RAIN PARTICLE SYSTEM
// ─────────────────────────────────────────────────────────────────────

const rainGeo = new THREE.BufferGeometry();
const rainPos = new Float32Array(RAIN_COUNT * 3);
const rainVel = new Float32Array(RAIN_COUNT);

for (let i = 0; i < RAIN_COUNT; i++) {
  rainPos[i * 3]     = (Math.random() - 0.5) * RAIN_SPREAD;
  rainPos[i * 3 + 1] = Math.random() * RAIN_HEIGHT;
  rainPos[i * 3 + 2] = (Math.random() - 0.5) * RAIN_SPREAD;
  rainVel[i]         = 0.25 + Math.random() * 0.30;
}
rainGeo.setAttribute('position', new THREE.BufferAttribute(rainPos, 3));

const rainMat = new THREE.PointsMaterial({
  color: 0x606878, size: 0.055, transparent: true, opacity: 0.22
});
const rainMesh = new THREE.Points(rainGeo, rainMat);
scene.add(rainMesh);

function tickRain(anchor) {
  const p = rainGeo.attributes.position.array;
  for (let i = 0; i < RAIN_COUNT; i++) {
    p[i * 3 + 1] -= rainVel[i];
    p[i * 3]     += 0.015;
    p[i * 3 + 2] -= 0.008;
    if (p[i * 3 + 1] < -0.5) {
      p[i * 3]     = (Math.random() - 0.5) * RAIN_SPREAD;
      p[i * 3 + 1] = RAIN_HEIGHT;
      p[i * 3 + 2] = (Math.random() - 0.5) * RAIN_SPREAD;
    }
  }
  rainMesh.position.copy(anchor);
  rainGeo.attributes.position.needsUpdate = true;
}


// ─────────────────────────────────────────────────────────────────────
//  DYNAMIC CAMERA (enhanced lateral lag + lean)
// ─────────────────────────────────────────────────────────────────────
//  The camera chases the car's actual position (currentX), not the
//  target. Because currentX itself is already lagging behind targetX,
//  and the camera lags behind currentX, we get a double-damped,
//  very cinematic lateral sway.
// ─────────────────────────────────────────────────────────────────────

let camRoll = 0;
let camFov  = 66;
let camLagX = 0;              // camera's own smoothed X

function updateCamera(carPos, spd, rawSteer) {
  const sf = spd / MAX_SPEED;

  // Ideal position
  const ix = carPos.x * 0.35;
  const iy = 2.6 + sf * 0.55 + Math.abs(rawSteer) * 0.18;
  const iz = carPos.z + 6.8 + sf * 2.2;

  // Camera X lags extra behind the car's lateral position
  // (car already lags behind targetX, so this is double-damped)
  camLagX += (ix - camLagX) * 0.035;

  camera.position.x += (camLagX - camera.position.x) * 0.065;
  camera.position.y += (iy - camera.position.y) * 0.045;
  camera.position.z += (iz - camera.position.z) * 0.060;

  // Look-at
  const la = 22 + sf * 16;
  camera.lookAt(carPos.x * 0.55, 0.9, carPos.z - la);

  // Roll lean — stronger when steering, proportional to steer delta
  // Uses the difference between targetX and currentX as a "lean signal"
  const leanSignal = (targetX - currentX);           // positive = turning right
  const tr = -leanSignal * 0.035 - rawSteer * 0.012; // blend input + body lean
  camRoll += (tr - camRoll) * 0.032;
  camera.rotation.z = camRoll;

  // FOV stretch
  const tf = 64 + sf * 10;
  camFov += (tf - camFov) * 0.025;
  camera.fov = camFov;
  camera.updateProjectionMatrix();
}


// ─────────────────────────────────────────────────────────────────────
//  INPUT
// ─────────────────────────────────────────────────────────────────────

const keys = {};

window.addEventListener('keydown', e => {
  // Pause toggle on P (only on initial press, not repeat)
  if (e.code === 'KeyP' && !e.repeat && !crashed) {
    paused = !paused;
    if (paused) {
      pauseOverlay.classList.add('active');
    } else {
      pauseOverlay.classList.remove('active');
    }
    return;
  }
  keys[e.code] = true;
});

window.addEventListener('keyup', e => { keys[e.code] = false; });


// ─────────────────────────────────────────────────────────────────────
//  LOOP TRACKING
// ─────────────────────────────────────────────────────────────────────

let loopCount   = 0;
let lastLoopIdx = 0;


// ─────────────────────────────────────────────────────────────────────
//  UTILITY
// ─────────────────────────────────────────────────────────────────────

function lerp(a, b, t) { return a + (b - a) * t; }


// ═══════════════════════════════════════════════════════════════════════
//  MAIN GAME LOOP
// ═══════════════════════════════════════════════════════════════════════

let lastT = 0;
spawnObstacles(0);

function frame(ts) {
  requestAnimationFrame(frame);

  const dt = Math.min((ts - lastT) / 1000, 0.05);
  lastT = ts;

  // ── Paused or crashed: freeze everything, still render ──────
  if (paused || crashed) {
    renderer.render(scene, camera);
    return;
  }

  // ── Input ────────────────────────────────────────────────────
  steer = 0;
  if (keys['ArrowLeft']  || keys['KeyA']) steer = -1;
  if (keys['ArrowRight'] || keys['KeyD']) steer =  1;

  prevSpeed = speed;
  if (keys['ArrowUp'] || keys['KeyW']) {
    speed = Math.min(MAX_SPEED, speed + ACCEL);
  } else if (keys['ArrowDown'] || keys['KeyS']) {
    speed = Math.max(MIN_SPEED, speed - BRAKE);
  } else {
    if (speed > BASE_SPEED)      speed = Math.max(BASE_SPEED, speed - DRAG);
    else if (speed < BASE_SPEED) speed = Math.min(BASE_SPEED, speed + DRAG * 0.4);
  }

  // ── Interpolated Steering ───────────────────────────────────
  //  The key press moves targetX. The car's actual position
  //  (currentX) chases it with a lerp, giving a heavy, floaty
  //  sensation — like piloting a boat on asphalt.
  targetX += steer * STEER_RATE * (0.4 + speed);
  targetX  = Math.max(-MAX_LATERAL, Math.min(MAX_LATERAL, targetX));
  currentX += (targetX - currentX) * STEER_LERP;

  // Forward
  progress += speed;

  // ── Record ───────────────────────────────────────────────────
  currentRecording.push({ x: currentX, z: progress % ROAD_LENGTH, speed });

  // ── Loop detection ───────────────────────────────────────────
  const curLoop = Math.floor(progress / ROAD_LENGTH);
  if (curLoop > lastLoopIdx) {
    loopCount++;
    lastLoopIdx = curLoop;

    if (currentRecording.length > 0) {
      allRecordings.push([...currentRecording]);
      ghosts.push(new Ghost(allRecordings[allRecordings.length - 1]));
      currentRecording = [];
    }
    spawnObstacles(loopCount);
  }

  // ── Positioning ──────────────────────────────────────────────
  const baseZ = curLoop * ROAD_LENGTH;

  // Player car: uses currentX (the interpolated position)
  playerCar.position.set(currentX, 0, -progress);

  // Visual steering rotation: proportional to the delta between
  // target and current, giving a natural body-roll effect
  const steerDelta = targetX - currentX;
  playerCar.rotation.y = -steerDelta * 0.06;

  // Nose pitch
  const accel    = speed - prevSpeed;
  const tgtPitch = accel * 2.5;
  carPitch = lerp(carPitch, tgtPitch, 0.10);
  playerCar.rotation.x = carPitch;

  // Headlights
  hlL.position.set(currentX - 0.62, 0.54, -progress - 2.4);
  hlR.position.set(currentX + 0.62, 0.54, -progress - 2.4);
  hlL.target.position.set(currentX - 1.5, -0.5, -progress - 50);
  hlR.target.position.set(currentX + 1.5, -0.5, -progress - 50);

  tailGlow.position.set(currentX, 0.54, -progress + 2.5);

  // ── Road tiling ──────────────────────────────────────────────
  const si = Math.floor(progress / ROAD_LENGTH);
  for (let i = 0; i < 3; i++) {
    segments[i].position.z = -(si - 1 + i) * ROAD_LENGTH;
  }

  // ── Street lamps ─────────────────────────────────────────────
  updateLamps(progress);

  // ── Ghosts ───────────────────────────────────────────────────
  for (const gh of ghosts) {
    gh.update(baseZ);

    // ── Collision check ──────────────────────────────────────
    if (gh.overlapsPlayer(currentX, 0, -progress)) {
      triggerCrash();
      break;                      // one crash is enough
    }
  }

  // ── Obstacles ────────────────────────────────────────────────
  for (const ob of liveObstacles) {
    ob.mesh.position.z = -(baseZ + ob.oz);
    ob.mesh.position.x = ob.ox;
  }

  // ── Rain ─────────────────────────────────────────────────────
  tickRain(playerCar.position);

  // ── Camera ───────────────────────────────────────────────────
  updateCamera(playerCar.position, speed, steer);

  // ── Render ───────────────────────────────────────────────────
  renderer.render(scene, camera);
}

requestAnimationFrame(frame);
</script>
</body>
</html>
