<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>the only car here is you</title>
<style>
  *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
  html,body{width:100%;height:100%;overflow:hidden;background:#000;cursor:none}
  canvas{display:block}
  #vignette{position:fixed;inset:0;z-index:4;pointer-events:none;background:radial-gradient(ellipse at 50% 48%,transparent 48%,rgba(0,0,0,0.58) 100%)}
  #mirror-frame{position:fixed;top:38px;left:50%;transform:translateX(-50%);width:22vw;min-width:180px;max-width:400px;aspect-ratio:4.2/1;border:1.5px solid rgba(55,55,55,0.45);border-radius:3px;z-index:5;pointer-events:none;box-shadow:inset 0 0 14px rgba(0,0,0,0.8),0 0 6px rgba(0,0,0,0.4)}
  #sols{position:fixed;top:16px;left:50%;transform:translateX(-50%);z-index:8;font-family:'Courier New',monospace;font-size:0.68rem;letter-spacing:0.35em;pointer-events:none;user-select:none;opacity:0;color:rgba(255,255,255,0);transition:opacity 0.5s ease,background 0.4s ease,color 0.4s ease}
  #sols.sign-mode{opacity:1;background:rgba(0,75,38,0.88);color:rgba(255,255,255,0.92);padding:6px 18px;border:1.5px solid rgba(255,255,255,0.55);border-radius:2px;font-size:0.72rem;letter-spacing:0.22em}
  #crash-overlay{position:fixed;inset:0;z-index:10;display:none;flex-direction:column;align-items:center;justify-content:center;gap:14px;background:#000;pointer-events:none}
  #crash-overlay.active{display:flex}
  #crash-overlay .msg{color:rgba(170,165,155,0.88);font-family:'Courier New',monospace;font-size:1.05rem;letter-spacing:0.25em}
  #crash-overlay .restart{color:rgba(120,115,105,0.40);font-family:'Courier New',monospace;font-size:0.55rem;letter-spacing:0.2em;margin-top:12px}
  #speedo{position:fixed;bottom:18px;right:18px;z-index:8;width:110px;height:110px;pointer-events:none;opacity:0.75}
  #vhs-timestamp{position:fixed;bottom:12px;left:16px;z-index:8;font-family:'Courier New',monospace;font-size:0.85rem;color:rgba(255,255,255,0.65);pointer-events:none;user-select:none;letter-spacing:0.08em;text-shadow:1px 1px 2px rgba(0,0,0,0.8)}
</style>
</head>
<body>
<div id="vignette"></div>
<div id="mirror-frame"></div>
<div id="sols"></div>
<canvas id="speedo" width="160" height="160"></canvas>
<div id="vhs-timestamp">REC ●</div>
<div id="crash-overlay"><span class="msg"></span><span class="restart">press r to restart the cycle.</span></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const ROAD_LENGTH=1000,ROAD_WIDTH=14,LANE_WIDTH=3.5,SHOULDER_EXTRA=3;
const LAMP_SPACING=40,LAMP_HEIGHT=9,LAMP_ARM_REACH=3.5,NUM_LAMP_SLOTS=14;
const FOG_DENSITY=0.03;
const BASE_SPEED=0.45,MAX_SPEED=1.0,MIN_SPEED=0.08,ACCEL=0.007,BRAKE=0.014,DRAG=0.0015;
const REVERSE_MAX=-0.4;
const STEER_SPEED_LOW=0.035;
const STEER_SPEED_HIGH=0.005; // Much less aggressive at high speeds
const STEER_SMOOTHING=0.15;
const WALL_INNER=ROAD_WIDTH/2+2-0.85;
const MERGE_FRAMES=120,MERGE_START_Y=-2.0,MERGE_START_Z=20;
const RAIN_COUNT=8000,RAIN_SPREAD=72,RAIN_HEIGHT=26,STREAK_LEN=0.25;
const COL_HX=0.85,COL_HZ=2.2,WHEEL_R=0.29,MIN_OBS_SPACING=ROAD_WIDTH*2;
const SIGN_SPACING=100,NUM_SIGN_SLOTS=5,VHS_SCALE=0.50;
const PED_MIN_INTERVAL=100,PED_MAX_INTERVAL=500;

// ── Renderer ─────────────────────────────────────────────────────────
const renderer=new THREE.WebGLRenderer({antialias:false});
renderer.setSize(window.innerWidth,window.innerHeight);renderer.setPixelRatio(1);
renderer.toneMapping=THREE.ACESFilmicToneMapping;renderer.toneMappingExposure=0.76;
renderer.physicallyCorrectLights=true;renderer.autoClear=false;
document.body.appendChild(renderer.domElement);
const scene=new THREE.Scene();scene.background=new THREE.Color(0x010102);
scene.fog=new THREE.FogExp2(0x010102,FOG_DENSITY);
const camera=new THREE.PerspectiveCamera(66,window.innerWidth/window.innerHeight,0.1,600);
camera.layers.enable(1); // Enable layer 1 so we can see the player car body
const mirrorCam=new THREE.PerspectiveCamera(58,4.2,0.5,280);
mirrorCam.layers.set(0);
const mirrorEl=document.getElementById('mirror-frame');
scene.add(new THREE.AmbientLight(0x14141e,0.24));

// ── VHS ──────────────────────────────────────────────────────────────
const vhsRT=new THREE.WebGLRenderTarget(Math.floor(window.innerWidth*VHS_SCALE),Math.floor(window.innerHeight*VHS_SCALE),{minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter});
const vhsShader=new THREE.ShaderMaterial({
  uniforms:{tDiffuse:{value:vhsRT.texture},time:{value:0},resolution:{value:new THREE.Vector2(vhsRT.width,vhsRT.height)},grainBoost:{value:1.0}},
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D tDiffuse;uniform float time;uniform vec2 resolution;uniform float grainBoost;varying vec2 vUv;
    float rand(vec2 co){return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);}
    vec2 fisheye(vec2 uv){
      vec2 centered=uv*2.0-1.0;
      float dist=length(centered);
      float distortion=1.0+dist*dist*0.08;
      return centered/distortion*0.5+0.5;
    }
    void main(){
      vec2 uv=fisheye(vUv);
      float w=sin(uv.y*90.0+time*3.5)*0.0004+sin(uv.y*220.0+time*8.0)*0.00015;
      float gs=rand(vec2(floor(time*2.5),floor(uv.y*12.0)));float gl=step(0.998,gs);w+=gl*(rand(vec2(time,uv.y))-0.5)*0.012;uv.x+=w;
      float ab=0.0012+gl*0.005;float r=texture2D(tDiffuse,vec2(uv.x+ab,uv.y)).r;float g=texture2D(tDiffuse,uv).g;float b=texture2D(tDiffuse,vec2(uv.x-ab,uv.y)).b;
      vec3 col=vec3(r,g,b);col-=sin(vUv.y*resolution.y*1.8)*0.015;col+=(rand(vUv+fract(time*0.7))-0.5)*0.07*grainBoost;
      col*=smoothstep(0.0,0.03,vUv.y)*smoothstep(1.0,0.97,vUv.y);
      float br2=texture2D(tDiffuse,vec2(uv.x+0.0015,uv.y)).r;col.r=mix(col.r,br2,0.10);
      float lum=dot(col,vec3(0.299,0.587,0.114));col=mix(vec3(lum),col,0.86);col.r*=1.03;col.b*=0.95;
      float vig=1.0-smoothstep(0.5,1.6,length((vUv-0.5)*vec2(1.3,1.0)));col*=vig*0.93+0.07;
      gl_FragColor=vec4(col,1.0);}`
});
const vhsScene=new THREE.Scene();const vhsCamera=new THREE.OrthographicCamera(-1,1,1,-1,0,1);
vhsScene.add(new THREE.Mesh(new THREE.PlaneGeometry(2,2),vhsShader));
window.addEventListener('resize',()=>{camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);vhsRT.setSize(Math.floor(window.innerWidth*VHS_SCALE),Math.floor(window.innerHeight*VHS_SCALE));
  vhsShader.uniforms.resolution.value.set(vhsRT.width,vhsRT.height);});

// ── Road ─────────────────────────────────────────────────────────────
const asphaltMat=new THREE.MeshStandardMaterial({color:0x1a1a1a,roughness:0.06,metalness:0.20});
const shoulderMat=new THREE.MeshStandardMaterial({color:0x0f0f0f,roughness:0.22,metalness:0.08});
const markingMat=new THREE.MeshStandardMaterial({color:0x55554a,roughness:0.25,emissive:0x0a0a08,emissiveIntensity:0.14});
const railMat=new THREE.MeshPhongMaterial({color:0x303030,specular:0x555555,shininess:30});
const medianMat=new THREE.MeshStandardMaterial({color:0x222222,roughness:0.5,metalness:0.05});
function createRoadSegment(){const g=new THREE.Group();
  const rd=new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH,ROAD_LENGTH),asphaltMat);rd.rotation.x=-Math.PI/2;rd.position.set(0,0,-ROAD_LENGTH/2);g.add(rd);
  const sh=new THREE.Mesh(new THREE.PlaneGeometry(ROAD_WIDTH+SHOULDER_EXTRA*2,ROAD_LENGTH),shoulderMat);sh.rotation.x=-Math.PI/2;sh.position.set(0,-0.015,-ROAD_LENGTH/2);g.add(sh);
  const dL=4,gL=7,cy=dL+gL,nD=Math.ceil(ROAD_LENGTH/cy),dG=new THREE.PlaneGeometry(0.13,dL);
  for(const lx of[-LANE_WIDTH/2,LANE_WIDTH/2])for(let i=0;i<nD;i++){const d=new THREE.Mesh(dG,markingMat);d.rotation.x=-Math.PI/2;d.position.set(lx,0.006,-(i*cy+dL/2));g.add(d);}
  const eG=new THREE.PlaneGeometry(0.14,ROAD_LENGTH);
  for(const sx of[-1,1]){const e=new THREE.Mesh(eG,markingMat);e.rotation.x=-Math.PI/2;e.position.set(sx*(ROAD_WIDTH/2-0.5),0.006,-ROAD_LENGTH/2);g.add(e);}
  for(const sx of[-1,1]){const r=new THREE.Mesh(new THREE.BoxGeometry(0.07,0.7,ROAD_LENGTH),railMat);r.position.set(sx*(ROAD_WIDTH/2+2),0.35,-ROAD_LENGTH/2);g.add(r);
    const r2=new THREE.Mesh(new THREE.BoxGeometry(0.05,0.08,ROAD_LENGTH),railMat);r2.position.set(sx*(ROAD_WIDTH/2+2),0.08,-ROAD_LENGTH/2);g.add(r2);}
  const med=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.35,ROAD_LENGTH),medianMat);med.position.set(-(ROAD_WIDTH/2+3),0.17,-ROAD_LENGTH/2);g.add(med);return g;}
const segments=[createRoadSegment(),createRoadSegment(),createRoadSegment()];segments.forEach(s=>scene.add(s));

// ── Lamps ────────────────────────────────────────────────────────────
const lampPostMat=new THREE.MeshPhongMaterial({color:0x252525,specular:0x333333,shininess:15});
const lampGlassMat=new THREE.MeshBasicMaterial({color:0xffe8c0,transparent:true,opacity:0.75});
function createLampPost(){const g=new THREE.Group();
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.075,0.10,LAMP_HEIGHT,6),lampPostMat);pole.position.y=LAMP_HEIGHT/2;g.add(pole);
  const arm=new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,LAMP_ARM_REACH,4),lampPostMat);arm.rotation.z=Math.PI/2;arm.position.set(-LAMP_ARM_REACH/2,LAMP_HEIGHT-0.15,0);g.add(arm);
  const hs=new THREE.Mesh(new THREE.BoxGeometry(0.45,0.12,0.75),new THREE.MeshPhongMaterial({color:0x1a1a1a}));hs.position.set(-LAMP_ARM_REACH,LAMP_HEIGHT-0.22,0);g.add(hs);
  const gl=new THREE.Mesh(new THREE.PlaneGeometry(0.38,0.65),lampGlassMat);gl.rotation.x=-Math.PI/2;gl.position.set(-LAMP_ARM_REACH,LAMP_HEIGHT-0.29,0);g.add(gl);
  const bs=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.22,0.12,6),lampPostMat);bs.position.y=0.06;g.add(bs);return g;}
const lampPosts=[],lampLights=[];
for(let i=0;i<NUM_LAMP_SLOTS;i++){const p=createLampPost();scene.add(p);lampPosts.push(p);const l=new THREE.PointLight(0xffe0a0,380,95,1.6);scene.add(l);lampLights.push(l);}
function updateLamps(prog){const b=Math.floor(prog/LAMP_SPACING)-4;
  for(let i=0;i<NUM_LAMP_SLOTS;i++){const idx=b+i,z=idx*LAMP_SPACING,side=(idx%2===0)?1:-1;
    lampPosts[i].position.set(side*(ROAD_WIDTH/2+2),0,-z);lampPosts[i].scale.x=side;
    lampLights[i].position.set(side*(ROAD_WIDTH/2-1),LAMP_HEIGHT-0.3,-z);}}
const lampFS=[];for(let i=0;i<NUM_LAMP_SLOTS;i++)lampFS.push({active:false,timer:0,seed:Math.random()*1000});
function updateLampFlicker(){for(let i=0;i<NUM_LAMP_SLOTS;i++){const fs=lampFS[i];
  if(!fs.active){if(Math.random()<0.0015){fs.active=true;fs.timer=25+Math.floor(Math.random()*70);}lampLights[i].intensity=380;}
  else{fs.timer--;lampLights[i].intensity=Math.sin(fs.timer*0.9+fs.seed)*Math.sin(fs.timer*2.3)>0.05?380:15;
    if(fs.timer<=0){fs.active=false;lampLights[i].intensity=380;}}}}

// ── Simple sedan model ───────────────────────────────────────────────
function createSedan(colour){
  const g=new THREE.Group();g.userData.wheelGroups=[];
  const bodyMat=new THREE.MeshPhongMaterial({color:colour,specular:0x666666,shininess:115});
  const glassMat=new THREE.MeshPhongMaterial({color:0x080812,specular:0xaaaaaa,shininess:140,transparent:true,opacity:0.58,depthWrite:false});
  const trimMat=new THREE.MeshPhongMaterial({color:0x0c0c0c,specular:0x444444,shininess:35});
  const rubberMat=new THREE.MeshPhongMaterial({color:0x080808,specular:0x0e0e0e,shininess:6});
  const chromeMat=new THREE.MeshPhongMaterial({color:0x222222,specular:0x999999,shininess:90});

  const s=new THREE.Shape();
  s.moveTo(-2.10,0.20);s.lineTo(-2.10,0.38);
  s.quadraticCurveTo(-2.05,0.52,-1.85,0.58);s.lineTo(-0.90,0.62);
  s.bezierCurveTo(-0.70,0.63,-0.45,0.95,-0.20,1.12);
  s.lineTo(0.40,1.16);
  s.bezierCurveTo(0.65,1.14,0.85,1.00,1.05,0.82);
  s.lineTo(1.65,0.62);s.quadraticCurveTo(1.95,0.52,2.10,0.38);
  s.lineTo(2.10,0.20);s.lineTo(-2.10,0.20);
  const BW=1.70;
  const bodyGeo=new THREE.ExtrudeGeometry(s,{depth:BW,bevelEnabled:true,bevelThickness:0.03,bevelSize:0.03,bevelSegments:2,curveSegments:14});
  const innerMat=new THREE.MeshPhongMaterial({color:0x0a0a0a,specular:0x111111,shininess:10});
  const innerGeo=new THREE.ExtrudeGeometry(s,{depth:BW-0.06,bevelEnabled:false,bevelThickness:0.01,bevelSize:0.01,bevelSegments:1,curveSegments:14});
  const inner=new THREE.Mesh(innerGeo,innerMat);inner.rotation.y=-Math.PI/2;inner.position.x=(BW-0.06)/2;inner.scale.setScalar(0.96);inner.position.y=0.01;
  inner.layers.set(1);
  g.add(inner);
  const bm=new THREE.Mesh(bodyGeo,bodyMat);
  bm.rotation.y=-Math.PI/2;bm.position.x=BW/2;g.add(bm);

  for(const sx of[-1,1]){
    const swF=new THREE.Mesh(new THREE.PlaneGeometry(0.55,0.28),glassMat);swF.rotation.y=sx*Math.PI/2;swF.position.set(sx*(BW/2+0.02),1.00,-0.10);g.add(swF);
    const swR=new THREE.Mesh(new THREE.PlaneGeometry(0.50,0.26),glassMat);swR.rotation.y=sx*Math.PI/2;swR.position.set(sx*(BW/2+0.02),0.98,0.42);g.add(swR);}

  const hlMat=new THREE.MeshBasicMaterial({color:0xeeeedd});
  for(const sx of[-0.55,0.55]){
    const hl=new THREE.Mesh(new THREE.BoxGeometry(0.28,0.12,0.06),hlMat);hl.position.set(sx,0.50,-2.11);g.add(hl);}
  const tlMat=new THREE.MeshBasicMaterial({color:0xff3333,emissive:0xff0000,emissiveIntensity:1.0});
  const tlGlow=new THREE.MeshBasicMaterial({color:0xff3333,transparent:true,opacity:0.0,depthWrite:false});
  for(const sx of[-0.55,0.55]){
    const tl=new THREE.Mesh(new THREE.BoxGeometry(0.24,0.10,0.04),tlMat);tl.position.set(sx,0.48,2.11);g.add(tl);
    const tg=new THREE.Mesh(new THREE.SphereGeometry(0.18,6,4),tlGlow);tg.position.set(sx,0.48,2.11);g.add(tg);}

  const gr=new THREE.Mesh(new THREE.BoxGeometry(1.0,0.10,0.04),new THREE.MeshPhongMaterial({color:0x040404}));gr.position.set(0,0.40,-2.11);g.add(gr);
  const bf=new THREE.Mesh(new THREE.BoxGeometry(1.56,0.04,0.04),chromeMat);bf.position.set(0,0.32,-2.11);g.add(bf);
  const br=new THREE.Mesh(new THREE.BoxGeometry(1.56,0.04,0.04),chromeMat);br.position.set(0,0.32,2.11);g.add(br);

  const tG=new THREE.TorusGeometry(0.27,0.09,8,18),rG=new THREE.CylinderGeometry(0.18,0.18,0.14,14);
  const wPos=[[-0.80,0.27,-1.30],[0.80,0.27,-1.30],[-0.80,0.27,1.30],[0.80,0.27,1.30]];
  for(const[wx,wy,wz]of wPos){const wG=new THREE.Group();wG.position.set(wx,wy,wz);
    const t=new THREE.Mesh(tG,rubberMat);t.rotation.y=Math.PI/2;wG.add(t);
    const rm=new THREE.Mesh(rG,chromeMat);rm.rotation.z=Math.PI/2;wG.add(rm);
    g.add(wG);g.userData.wheelGroups.push(wG);}

  for(const sx of[-1,1]){const st=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.025,0.04),trimMat);st.position.set(sx*0.90,0.88,-0.40);g.add(st);
    const hd=new THREE.Mesh(new THREE.SphereGeometry(0.035,6,4),chromeMat);hd.position.set(sx*0.98,0.88,-0.40);g.add(hd);}
  for(const sx of[-1,1]){const sm=new THREE.Mesh(new THREE.BoxGeometry(0.005,0.35,0.005),trimMat);sm.position.set(sx*(BW/2+0.02),0.52,0.10);g.add(sm);}

  return g;
}

// ── Player ───────────────────────────────────────────────────────────
const playerCar=createSedan(0xE8E8E8);
scene.add(playerCar);
// Note: Player car body stays on layer 0 (visible to both cameras)
// Only the inner shell is on layer 1

function makeHeadlight(){const pl=new THREE.PointLight(0xfff2da,800,800,0.8);scene.add(pl);return pl;}
const hlL=makeHeadlight(),hlR=makeHeadlight();
const tailGlow=new THREE.PointLight(0xaa0000,3,12,2);scene.add(tailGlow);
const BRAKE_GLOW_MAX=35,BRAKE_GLOW_IDLE=3;

const arrowShape=new THREE.Shape();
arrowShape.moveTo(0,0);arrowShape.lineTo(-0.18,0.30);arrowShape.lineTo(0.18,0.30);arrowShape.lineTo(0,0);
const arrowGeo=new THREE.ShapeGeometry(arrowShape);
const arrowMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.55,side:THREE.DoubleSide,depthWrite:false});
const arrowMesh=new THREE.Mesh(arrowGeo,arrowMat);arrowMesh.visible=false;scene.add(arrowMesh);

let progress=0,currentX=0,speed=BASE_SPEED,prevSpeed=BASE_SPEED,steer=0,currentSteerInput=0,carPitch=0,heading=0;

let damageLevel=0;const playerBodyMat=playerCar.children[1].material;const ORIGINAL_COLOR=new THREE.Color(0xE8E8E8);
const origBodyPos=playerCar.children[1].geometry.attributes.position.array.slice();

// Headlight power system
let headlightPower=1.0;
let hlFlickerTimer=0;
let hlFlickerDuration=0;

// Road spray
const SPRAY_COUNT=80;
const sprayPos=new Float32Array(SPRAY_COUNT*3);const sprayVel=[];const sprayLife=[];
for(let i=0;i<SPRAY_COUNT;i++){sprayPos[i*3+1]=-100;sprayVel.push({x:0,y:0,z:0});sprayLife.push(0);}
const sprayGeo=new THREE.BufferGeometry();sprayGeo.setAttribute('position',new THREE.BufferAttribute(sprayPos,3));
const sprayMat=new THREE.PointsMaterial({color:0x556677,size:0.05,transparent:true,opacity:0.0,depthWrite:false,sizeAttenuation:true});
const sprayMesh=new THREE.Points(sprayGeo,sprayMat);scene.add(sprayMesh);
function emitSpray(cosH,sinH){
  const absSpd=Math.abs(speed);if(absSpd<0.9)return;
  const count=Math.floor(absSpd*3);
  for(const wz of[1.10]){for(const wx of[-0.76,0.76]){
    for(let k=0;k<count;k++){for(let j=0;j<SPRAY_COUNT;j++){if(sprayLife[j]<=0){
      const lx=wx*0.8,lz=wz*1.1;
      sprayPos[j*3]=currentX+lx*cosH+lz*sinH+(Math.random()-0.5)*0.3;
      sprayPos[j*3+1]=0.05+Math.random()*0.15;
      sprayPos[j*3+2]=-progress+(-lx*sinH+lz*cosH)+(Math.random()-0.5)*0.3;
      sprayVel[j]={x:(Math.random()-0.5)*0.02,y:0.01+Math.random()*0.02,z:sinH*absSpd*0.3+cosH*absSpd*0.15+(Math.random()-0.5)*0.04};
      sprayLife[j]=8+Math.random()*15;break;}}}}}
}
function updateSpray(){
  const absSpd=Math.abs(speed);sprayMat.opacity=absSpd>0.9?Math.min(0.15,(absSpd-0.9)*0.30):0.0;
  for(let i=0;i<SPRAY_COUNT;i++){if(sprayLife[i]>0){sprayLife[i]--;
    sprayPos[i*3]+=sprayVel[i].x;sprayPos[i*3+1]+=sprayVel[i].y;sprayPos[i*3+2]+=sprayVel[i].z;
    sprayVel[i].y-=0.001;}else{sprayPos[i*3+1]=-100;}}
  sprayGeo.attributes.position.needsUpdate=true;}

// Distant landmarks
const landmarks=[];const landmarkMat=new THREE.MeshPhongMaterial({color:0x0a0a0c,specular:0x111111,shininess:5});
function createWaterTower(){const g=new THREE.Group();
  const legs=new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.5,8,4),landmarkMat);legs.position.y=4;g.add(legs);
  const tank=new THREE.Mesh(new THREE.CylinderGeometry(2.5,2.0,3,8),landmarkMat);tank.position.y=9.5;g.add(tank);
  const cap=new THREE.Mesh(new THREE.ConeGeometry(2.6,1.5,8),landmarkMat);cap.position.y=11.5;g.add(cap);return g;}
function createBillboard(){const g=new THREE.Group();
  const p1=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.18,6,4),landmarkMat);p1.position.set(-1.5,3,0);g.add(p1);
  const p2=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.18,6,4),landmarkMat);p2.position.set(1.5,3,0);g.add(p2);
  const board=new THREE.Mesh(new THREE.BoxGeometry(5,2.5,0.15),landmarkMat);board.position.set(0,7,0);g.add(board);return g;}
function createSilo(){const g=new THREE.Group();
  const tank=new THREE.Mesh(new THREE.CylinderGeometry(2.2,2.2,14,8),landmarkMat);tank.position.y=7;g.add(tank);
  const dome=new THREE.Mesh(new THREE.SphereGeometry(2.2,8,6,0,Math.PI*2,0,Math.PI/2),landmarkMat);dome.position.y=14;g.add(dome);
  const ladder=new THREE.Mesh(new THREE.BoxGeometry(0.15,14,0.08),landmarkMat);ladder.position.set(2.3,7,0);g.add(ladder);return g;}
function createRadioTower(){const g=new THREE.Group();
  const base=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.6,5,4),landmarkMat);base.position.y=2.5;g.add(base);
  const mid=new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.2,8,4),landmarkMat);mid.position.y=9;g.add(mid);
  const top=new THREE.Mesh(new THREE.CylinderGeometry(0.10,0.15,6,4),landmarkMat);top.position.y=16;g.add(top);
  const tip=new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.10,3,4),landmarkMat);tip.position.y=20.5;g.add(tip);
  for(const h of[4,10,15]){
    const beam=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.08,0.08),landmarkMat);beam.position.y=h;g.add(beam);}
  return g;}
function createWindmill(){const g=new THREE.Group();
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.25,0.35,12,6),landmarkMat);pole.position.y=6;g.add(pole);
  const nacelle=new THREE.Mesh(new THREE.BoxGeometry(1.2,0.8,0.8),landmarkMat);nacelle.position.y=12;g.add(nacelle);
  const bladeGeo=new THREE.BoxGeometry(0.12,5.0,0.8);
  for(let i=0;i<3;i++){
    const blade=new THREE.Mesh(bladeGeo,landmarkMat);
    blade.position.set(0,12,0.6);
    blade.rotation.z=(i*Math.PI*2/3);
    const pivotY=12;
    blade.position.y=pivotY+2.5*Math.sin(i*Math.PI*2/3);
    blade.position.x=2.5*Math.cos(i*Math.PI*2/3);
    g.add(blade);
  }
  g.userData.blades=[];
  return g;
}
function createPowerLines(){const g=new THREE.Group();
  for(let i=0;i<3;i++){
    const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.15,8,4),landmarkMat);
    pole.position.set(i*6-6,4,0);g.add(pole);
    const arm=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.08,0.08),landmarkMat);
    arm.position.set(i*6-6,7.8,0);g.add(arm);
  }
  const wireGeo=new THREE.BufferGeometry();
  const wireVerts=[];
  for(let w=-1;w<=1;w++){
    for(let i=0;i<2;i++){
      const x1=(i*6-6)+w*0.8,x2=((i+1)*6-6)+w*0.8;
      const y=7.5;
      wireVerts.push(x1,y,0,x2,y,0);
    }
  }
  wireGeo.setAttribute('position',new THREE.Float32BufferAttribute(wireVerts,3));
  const wireMat=new THREE.LineBasicMaterial({color:0x1a1a1a});
  const wires=new THREE.LineSegments(wireGeo,wireMat);
  g.add(wires);
  return g;
}
function createSmallBuilding(){const g=new THREE.Group();
  const build=new THREE.Mesh(new THREE.BoxGeometry(4,6,4),landmarkMat);build.position.y=3;g.add(build);
  const roof=new THREE.Mesh(new THREE.ConeGeometry(3,2,4),landmarkMat);roof.position.y=7;roof.rotation.y=Math.PI/4;g.add(roof);return g;}

// The Constant Mountain
function createMountain(){
  const g=new THREE.Group();
  const mountain=new THREE.Mesh(new THREE.ConeGeometry(80,160,32),landmarkMat);
  mountain.position.y=80;
  g.add(mountain);
  g.userData.mountain=mountain;
  return g;
}
let constantMountain=null;
let mountainInitialDistance=0;

function spawnLandmarks(loopNum){
  for(const lm of landmarks)scene.remove(lm);landmarks.length=0;
  
  // Clear mountain on restart
  if(constantMountain){
    scene.remove(constantMountain);
    constantMountain=null;
  }
  
  const rng=seededRNG(loopNum*3917+11);
  const types=[createWaterTower,createBillboard,createSilo,createRadioTower,createWindmill,createPowerLines,createSmallBuilding];
  for(let i=0;i<12;i++){
    const side=(i%2===0)?1:-1;const dist=25+rng()*50;
    const z=rng()*ROAD_LENGTH;
    const typeIdx=Math.floor(rng()*types.length);
    const lm=types[typeIdx]();
    lm.position.set(side*dist,0,0);lm.userData.oz=z;
    scene.add(lm);landmarks.push(lm);
  }
  
  // Spawn mountain on loop 1
  if(loopNum===1){
    constantMountain=createMountain();
    constantMountain.position.set(150,0,-300);
    mountainInitialDistance=300;
    scene.add(constantMountain);
  }
}

let targetFogDensity=FOG_DENSITY;let currentFogDensity=FOG_DENSITY;

// Wrong-way semi truck
let wrongWayTimer=0;const WRONG_WAY_LIMIT=180;
let semiTruck=null;let semiActive=false;let semiZ=0;
function createSemiTruck(){
  const g=new THREE.Group();
  const cabMat=new THREE.MeshPhongMaterial({color:0x2a2a2a,specular:0x555555,shininess:40});
  const trailMat=new THREE.MeshPhongMaterial({color:0x222222,specular:0x333333,shininess:20});
  const chromeMat2=new THREE.MeshPhongMaterial({color:0x333333,specular:0xaaaaaa,shininess:80});
  const cab=new THREE.Mesh(new THREE.BoxGeometry(2.6,2.4,2.8),cabMat);cab.position.set(0,1.5,-1.2);g.add(cab);
  const visor=new THREE.Mesh(new THREE.BoxGeometry(2.7,0.08,0.5),cabMat);visor.position.set(0,2.75,-2.1);g.add(visor);
  const wsMat=new THREE.MeshPhongMaterial({color:0x0a0a18,specular:0x888888,shininess:120,transparent:true,opacity:0.5});
  const ws=new THREE.Mesh(new THREE.PlaneGeometry(2.3,1.2),wsMat);ws.position.set(0,2.0,-2.62);g.add(ws);
  const bump=new THREE.Mesh(new THREE.BoxGeometry(2.8,0.35,0.20),chromeMat2);bump.position.set(0,0.38,-2.70);g.add(bump);
  const grille=new THREE.Mesh(new THREE.BoxGeometry(2.2,0.8,0.08),new THREE.MeshPhongMaterial({color:0x0c0c0c}));grille.position.set(0,0.90,-2.64);g.add(grille);
  const trail=new THREE.Mesh(new THREE.BoxGeometry(2.6,3.0,12.0),trailMat);trail.position.set(0,1.8,5.0);g.add(trail);
  const under=new THREE.Mesh(new THREE.BoxGeometry(2.0,0.4,11.5),new THREE.MeshPhongMaterial({color:0x111111}));under.position.set(0,0.22,5.0);g.add(under);
  const wheelMat=new THREE.MeshPhongMaterial({color:0x0a0a0a});
  for(const wz of[-2.0,9.5,10.5]){for(const sx of[-1.2,1.2]){
    const wh=new THREE.Mesh(new THREE.CylinderGeometry(0.45,0.45,0.30,10),wheelMat);
    wh.rotation.z=Math.PI/2;wh.position.set(sx,0.45,wz);g.add(wh);}}
  const hlM=new THREE.MeshBasicMaterial({color:0xffffff});
  for(const sx of[-0.9,0.9]){const hl=new THREE.Mesh(new THREE.BoxGeometry(0.35,0.22,0.06),hlM);hl.position.set(sx,1.1,-2.66);g.add(hl);}
  const hlGlow=new THREE.PointLight(0xffffdd,300,80,1.5);hlGlow.position.set(0,1.5,-3.0);g.add(hlGlow);
  const markerMat=new THREE.MeshBasicMaterial({color:0xffaa00,transparent:true,opacity:0.6});
  for(const mz of[-1.0,3.0,7.0,10.0]){for(const sx of[-1.35,1.35]){
    const mk=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.06,0.12),markerMat);mk.position.set(sx,0.60,mz);g.add(mk);}}
  g.visible=false;return g;}
semiTruck=createSemiTruck();scene.add(semiTruck);

// ── Pedestrian crossing ──────────────────────────────────────────────
let pedestrianActive=false;let pedestrianX=0;let pedestrianZ=0;let pedestrianDir=1;let nextPedestrianSol=0;
function createPedestrian(){
  const g=new THREE.Group();
  const bodyMat=new THREE.MeshPhongMaterial({color:0xf5f5f5,specular:0x888888,shininess:20});
  const body=new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.25,1.0,8),bodyMat);body.position.y=1.3;g.add(body);
  const head=new THREE.Mesh(new THREE.SphereGeometry(0.22,8,8),bodyMat);head.position.y=2.0;g.add(head);
  const armGeo=new THREE.CylinderGeometry(0.08,0.08,0.8,6);
  const armL=new THREE.Mesh(armGeo,bodyMat);armL.position.set(-0.35,1.3,0);armL.rotation.z=0.3;g.add(armL);
  const armR=new THREE.Mesh(armGeo,bodyMat);armR.position.set(0.35,1.3,0);armR.rotation.z=-0.3;g.add(armR);
  const legGeo=new THREE.CylinderGeometry(0.09,0.09,0.9,6);
  const legL=new THREE.Mesh(legGeo,bodyMat);legL.position.set(-0.15,0.55,0);g.add(legL);
  const legR=new THREE.Mesh(legGeo,bodyMat);legR.position.set(0.15,0.55,0);g.add(legR);
  
  const censorMat=new THREE.MeshBasicMaterial({color:0x000000});
  const censorBox=new THREE.Mesh(new THREE.BoxGeometry(1.5,2.5,1.0),censorMat);
  censorBox.position.y=1.25;g.add(censorBox);
  
  g.visible=false;return g;
}
const pedestrian=createPedestrian();scene.add(pedestrian);
function spawnPedestrian(){
  const sols=Math.floor(progress/10);
  if(sols>=nextPedestrianSol&&!pedestrianActive){
    pedestrianActive=true;
    const startSide=Math.random()<0.5?-1:1;
    pedestrianX=startSide*(ROAD_WIDTH/2+4);
    pedestrianDir=startSide>0?-1:1;
    pedestrianZ=progress+60+Math.random()*40;
    pedestrian.visible=true;
    pedestrian.position.set(pedestrianX,0,pedestrianZ);
    pedestrian.rotation.y=startSide>0?-Math.PI/2:Math.PI/2;
    nextPedestrianSol=sols+PED_MIN_INTERVAL+Math.floor(Math.random()*(PED_MAX_INTERVAL-PED_MIN_INTERVAL));
  }
}
function updatePedestrian(){
  if(!pedestrianActive)return;
  const crossSpeed=0.05;
  pedestrianX+=pedestrianDir*crossSpeed;
  pedestrian.position.x=pedestrianX;
  pedestrian.position.z=pedestrianZ;
  
  if(Math.abs(pedestrianX)>ROAD_WIDTH/2+5){
    pedestrianActive=false;
    pedestrian.visible=false;
  }
  
  const distX=Math.abs(pedestrianX-currentX);
  const distZ=Math.abs(pedestrianZ-progress);
  if(distX<0.9&&distZ<2.0){
    const randomSeconds=10*60+Math.floor(Math.random()*(50*60));
    const mins=Math.floor(randomSeconds/60);
    const secs=randomSeconds%60;
    crashMsgEl.textContent='you killed yourself in '+String(mins).padStart(2,'0')+':'+String(secs).padStart(2,'0')+' minutes.';
    triggerCrash(null);
    pedestrianActive=false;
    pedestrian.visible=false;
  }
}

// ── The Stalker ──────────────────────────────────────────────────────
let mirrorDissonanceActive=true; // Start with ghosts visible
function createStalker(){
  const g=new THREE.Group();
  const headlightMat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.7});
  const leftLight=new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8),headlightMat);
  leftLight.position.set(-0.6,0.5,0);
  g.add(leftLight);
  const rightLight=new THREE.Mesh(new THREE.SphereGeometry(0.15,8,8),headlightMat);
  rightLight.position.set(0.6,0.5,0);
  g.add(rightLight);
  
  // Add dim point lights
  const leftGlow=new THREE.PointLight(0xffffff,50,20,2);
  leftGlow.position.set(-0.6,0.5,0);
  g.add(leftGlow);
  const rightGlow=new THREE.PointLight(0xffffff,50,20,2);
  rightGlow.position.set(0.6,0.5,0);
  g.add(rightGlow);
  
  g.layers.set(0); // Visible in mirror
  g.visible=false;
  return g;
}
const stalker=createStalker();
scene.add(stalker);

// ── Spark particles ──────────────────────────────────────────────────
const SPARK_COUNT=60;
const sparkPos=new Float32Array(SPARK_COUNT*3);const sparkVel=[];const sparkLife=[];
for(let i=0;i<SPARK_COUNT;i++){sparkPos[i*3+1]=-100;sparkVel.push({x:0,y:0,z:0});sparkLife.push(0);}
const sparkGeo=new THREE.BufferGeometry();sparkGeo.setAttribute('position',new THREE.BufferAttribute(sparkPos,3));
const sparkMat=new THREE.PointsMaterial({color:0xffaa33,size:0.06,transparent:true,opacity:0.9,depthWrite:false});
const sparkMesh=new THREE.Points(sparkGeo,sparkMat);scene.add(sparkMesh);
function emitSparks(cx,cz,side){for(let i=0;i<4;i++)for(let j=0;j<SPARK_COUNT;j++){if(sparkLife[j]<=0){
  sparkPos[j*3]=cx+side*0.85;sparkPos[j*3+1]=0.15+Math.random()*0.25;sparkPos[j*3+2]=cz+(Math.random()-0.5)*1.5;
  sparkVel[j]={x:side*(0.04+Math.random()*0.08),y:0.04+Math.random()*0.06,z:(Math.random()-0.5)*0.08};
  sparkLife[j]=8+Math.random()*18;break;}}}
function updateSparks(){for(let i=0;i<SPARK_COUNT;i++){if(sparkLife[i]>0){sparkLife[i]--;
  sparkPos[i*3]+=sparkVel[i].x;sparkPos[i*3+1]+=sparkVel[i].y;sparkPos[i*3+2]+=sparkVel[i].z;
  sparkVel[i].y-=0.004;}else{sparkPos[i*3+1]=-100;}}sparkGeo.attributes.position.needsUpdate=true;}

// ── Ghosts ───────────────────────────────────────────────────────────
const allRecordings=[];let currentRecording=[];
class Ghost{constructor(rec,spawnLoop){this.rec=rec;this.mesh=createSedan(0x1e1e28);
    this.mesh.children[1].material.color.copy(playerBodyMat.color);
    this.mesh.children[1].layers.set(1); // Set ghost body to layer 1 too
    this.frame=0;this.mFrame=0;this.merged=false;this.creationTime=performance.now();this.mesh.visible=true;
    this.spawnLoop=spawnLoop;
    this.lastPos={x:0,z:0};
    this.stationaryFrames=0;
    scene.add(this.mesh);}
  static ease(t){return t*t*(3-2*t);}
  update(currentLoopBase){
    const r=this.rec;if(!r.length)return;
    const f=r[this.frame%r.length];
    
    const rawZ=-(currentLoopBase+f.z);
    
    if(!this.merged){
      this.mFrame++;const t=Math.min(this.mFrame/MERGE_FRAMES,1),sv=Ghost.ease(t);
      this.mesh.position.set(f.x,MERGE_START_Y*(1-sv),rawZ+MERGE_START_Z*(1-sv));
      if(t>=1)this.merged=true;
    }
    else this.mesh.position.set(f.x,0,rawZ);
    
    if(f.drift!==undefined)this.mesh.rotation.y=f.drift;
    else{const nf=r[(this.frame+1)%r.length];this.mesh.rotation.y=-(nf.x-f.x)*0.35;}
    
    const dx=this.mesh.position.x-this.lastPos.x;
    const dz=this.mesh.position.z-this.lastPos.z;
    const moved=Math.abs(dx)+Math.abs(dz);
    if(moved<0.01&&this.merged){this.stationaryFrames++;}
    else{this.stationaryFrames=0;}
    this.lastPos.x=this.mesh.position.x;
    this.lastPos.z=this.mesh.position.z;
    
    this.frame=(this.frame+1)%r.length;
  }
  isStationary(){return this.stationaryFrames>60;}
  getWorldXZ(){return{x:this.mesh.position.x,z:this.mesh.position.z};}}
const ghosts=[];

// ── Obstacles (sedans only) ──────────────────────────────────────────
const liveObstacles=[];
function seededRNG(seed){let s=Math.abs(seed)||1;return()=>{s=(s*16807)%2147483647;return(s-1)/2147483646;};}
function spawnObstacles(loopNum){for(const o of liveObstacles)scene.remove(o.mesh);liveObstacles.length=0;if(loopNum===0)return;
  const rng=seededRNG(loopNum*6271+43),count=Math.min(4+Math.floor(loopNum*1.4),18),placed=[];
  for(let i=0;i<count;i++){let ox,oz,valid,att=0;
    do{ox=(rng()-0.5)*(ROAD_WIDTH-2);oz=rng()*(ROAD_LENGTH-80)+40;valid=true;for(const pz of placed)if(Math.abs(oz-pz)<MIN_OBS_SPACING){valid=false;break;}att++;}while(!valid&&att<40);
    if(!valid)continue;placed.push(oz);const mesh=createSedan(0x121216);mesh.rotation.y=(rng()-0.5)*0.5;
    mesh.children[1].layers.set(1); // Set obstacle body to layer 1
    scene.add(mesh);
    liveObstacles.push({mesh,ox,oz,lastPos:{x:0,z:0},stationaryFrames:0});}}

// ── Signs ────────────────────────────────────────────────────────────
function makeSignCanvas(){const c=document.createElement('canvas');c.width=512;c.height=256;return c;}
function drawSignText(ctx,l1,l2){ctx.fillStyle='#006633';ctx.fillRect(0,0,512,256);ctx.strokeStyle='#cccccc';ctx.lineWidth=5;ctx.strokeRect(8,8,496,240);
  ctx.fillStyle='#ffffff';ctx.textAlign='center';ctx.textBaseline='middle';
  if(l2){ctx.font='bold 38px Arial,sans-serif';ctx.fillText(l1,256,96);ctx.font='26px Arial,sans-serif';ctx.fillText(l2,256,168);}
  else{ctx.font='bold 44px Arial,sans-serif';ctx.fillText(l1,256,128);}}
function createRoadSign(){const g=new THREE.Group(),pM=new THREE.MeshPhongMaterial({color:0x606060,specular:0x444444,shininess:20}),pH=7.5;
  const pole=new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.10,pH,6),pM);pole.position.set(0,pH/2,0);g.add(pole);
  const aL=3.5,arm=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,aL,4),pM);arm.rotation.z=Math.PI/2;arm.position.set(-aL/2,pH-0.2,0);g.add(arm);
  const pW=4.4,pHt=2.2,cv=makeSignCanvas(),cx=cv.getContext('2d');drawSignText(cx,'0 Fathoms','');
  const tx=new THREE.CanvasTexture(cv),sM=new THREE.MeshStandardMaterial({map:tx,roughness:0.55,metalness:0.04});
  const pan=new THREE.Mesh(new THREE.PlaneGeometry(pW,pHt),sM);pan.position.set(-aL+0.6,pH-0.2,0);g.add(pan);
  const bk=new THREE.Mesh(new THREE.PlaneGeometry(pW,pHt),new THREE.MeshPhongMaterial({color:0x1a1a1a}));bk.rotation.y=Math.PI;bk.position.set(-aL+0.6,pH-0.2,-0.03);g.add(bk);
  for(const ox of[-1,1]){const sL=new THREE.SpotLight(0xffffff,45,7,Math.PI/4,0.65,1.8),tgt=new THREE.Object3D();
    tgt.position.set(-aL+0.6+ox,pH-0.8,0);sL.position.set(-aL+0.6+ox,pH+1,-0.45);sL.target=tgt;g.add(sL);g.add(tgt);
    const fx=new THREE.Mesh(new THREE.BoxGeometry(0.16,0.07,0.18),new THREE.MeshPhongMaterial({color:0x222222}));fx.position.set(-aL+0.6+ox,pH+0.95,-0.38);g.add(fx);}
  g.userData.canvas=cv;g.userData.ctx=cx;g.userData.texture=tx;g.userData.line1='';g.userData.line2='';g.userData.text='';return g;}
const roadSigns=[];for(let i=0;i<NUM_SIGN_SLOTS;i++){const s=createRoadSign();scene.add(s);roadSigns.push(s);}
function getSignContent(idx){const t=((idx%5)+5)%5;switch(t){
  case 0:return{l1:Math.floor(progress/10)+' Fathoms',l2:''};
  case 1:return{l1:ghosts.length+(ghosts.length===1?' iteration':' iterations'),l2:'active on road'};
  case 2:return{l1:'Loop '+loopCount,l2:Math.floor(progress/10)+' Fathoms'};
  case 3:return{l1:'no exit ahead.',l2:ghosts.length+' iterations.'};
  case 4:return{l1:Math.floor(progress/10)+' Fathoms',l2:ghosts.length+' iterations ahead.'};}}
function updateSignTexture(sign,l1,l2){if(sign.userData.line1===l1&&sign.userData.line2===l2)return;sign.userData.line1=l1;sign.userData.line2=l2;
  sign.userData.text=l2?(l1+'  —  '+l2):l1;drawSignText(sign.userData.ctx,l1,l2);sign.userData.texture.needsUpdate=true;}
function updateSigns(prog){const base=Math.floor(prog/SIGN_SPACING)-1,sx=ROAD_WIDTH/2+2.5;
  for(let i=0;i<NUM_SIGN_SLOTS;i++){const idx=base+i,z=idx*SIGN_SPACING;roadSigns[i].position.set(sx,0,-z);const c=getSignContent(idx);updateSignTexture(roadSigns[i],c.l1,c.l2);}}

// ── Rain ─────────────────────────────────────────────────────────────
const rainGeo=new THREE.BufferGeometry(),rainP=new Float32Array(RAIN_COUNT*6),rainV=new Float32Array(RAIN_COUNT);
for(let i=0;i<RAIN_COUNT;i++){const x=(Math.random()-0.5)*RAIN_SPREAD,y=Math.random()*RAIN_HEIGHT,z=(Math.random()-0.5)*RAIN_SPREAD;
  rainV[i]=0.30+Math.random()*0.35;const b=i*6;rainP[b]=x;rainP[b+1]=y;rainP[b+2]=z;rainP[b+3]=x+0.012;rainP[b+4]=y-STREAK_LEN;rainP[b+5]=z-0.006;}
rainGeo.setAttribute('position',new THREE.BufferAttribute(rainP,3));
const rainMesh=new THREE.LineSegments(rainGeo,new THREE.LineBasicMaterial({color:0x8899aa,transparent:true,opacity:0.30,depthWrite:false}));scene.add(rainMesh);
function tickRain(anchor){const p=rainGeo.attributes.position.array;
  for(let i=0;i<RAIN_COUNT;i++){const b=i*6,v=rainV[i];p[b+1]-=v;p[b+4]-=v;p[b]+=0.018;p[b+3]+=0.018;p[b+2]-=0.009;p[b+5]-=0.009;
    if(p[b+1]<-0.5){const x=(Math.random()-0.5)*RAIN_SPREAD,y=RAIN_HEIGHT+Math.random()*3,z=(Math.random()-0.5)*RAIN_SPREAD;
      p[b]=x;p[b+1]=y;p[b+2]=z;p[b+3]=x+0.012;p[b+4]=y-STREAK_LEN;p[b+5]=z-0.006;}}
  rainMesh.position.copy(anchor);rainGeo.attributes.position.needsUpdate=true;}

// ── Camera ───────────────────────────────────────────────────────────
let cameraMode=1;const CAM_MODES=2;
const cam3P=new THREE.Vector3(),cam3L=new THREE.Vector3();let cam3I=false;

// Mouse look for interior camera
let mouseLookYaw=0; // horizontal rotation
let mouseLookPitch=0; // vertical rotation
let targetYaw=0;
let targetPitch=0;
const MAX_YAW=150*Math.PI/180; // +/- 150 degrees
const MAX_PITCH=60*Math.PI/180; // +/- 60 degrees
const MOUSE_SENSITIVITY=0.006;
const LOOK_LERP=0.08; // Slower = more laggy/analog feel

window.addEventListener('mousemove',(e)=>{
  if(cameraMode===0 && !paused && !crashed){
    targetYaw-=e.movementX*MOUSE_SENSITIVITY;
    targetPitch+=e.movementY*MOUSE_SENSITIVITY;
    targetYaw=Math.max(-MAX_YAW,Math.min(MAX_YAW,targetYaw));
    targetPitch=Math.max(-MAX_PITCH,Math.min(MAX_PITCH,targetPitch));
  }
});

function cycleCamera(){
  cameraMode=(cameraMode+1)%CAM_MODES;
  cam3I=false;
  // Reset mouse look
  mouseLookYaw=0;
  mouseLookPitch=0;
  targetYaw=0;
  targetPitch=0;
}

function updateCameraSystem(spd){
  const cosH=Math.cos(heading),sinH=Math.sin(heading),sf=Math.abs(spd)/MAX_SPEED;
  if(cameraMode===0){
    playerCar.visible=false;arrowMesh.visible=false;
    
    // Smooth mouse look with lerp
    mouseLookYaw+=(targetYaw-mouseLookYaw)*LOOK_LERP;
    mouseLookPitch+=(targetPitch-mouseLookPitch)*LOOK_LERP;
    
    // Interior camera position
    camera.position.set(
      currentX+(-0.50)*cosH+(-0.35)*sinH,
      0.88,
      -progress+(0.50*sinH+(-0.35)*cosH)
    );
    
    // Look direction with mouse offset
    const lookDist=30;
    const lookX=currentX+(-sinH)*lookDist;
    const lookY=0.50;
    const lookZ=-progress+(-cosH)*lookDist;
    
    // Apply yaw rotation (left-right)
    const yawCos=Math.cos(mouseLookYaw);
    const yawSin=Math.sin(mouseLookYaw);
    const rotatedX=lookX+yawSin*10;
    const rotatedZ=lookZ+yawCos*10;
    
    // Apply pitch (up-down)
    const pitchedY=lookY+Math.sin(mouseLookPitch)*5;
    
    camera.lookAt(rotatedX,pitchedY,rotatedZ);
    camera.near=0.3;camera.fov=76;camera.updateProjectionMatrix();
  }else{
    playerCar.visible=true;arrowMesh.visible=true;
    const bd=3.5+sf*0.3,ch=1.8+sf*0.08,wx=currentX+sinH*bd,wy=ch,wz=-progress+cosH*bd;
    if(!cam3I){cam3P.set(wx,wy,wz);cam3L.set(currentX,0.5,-progress-15);cam3I=true;}
    // Faster lerp at high speeds so camera keeps up better
    const posLerp=0.10+sf*0.08;
    const lookLerp=0.12+sf*0.10;
    cam3P.x+=(wx-cam3P.x)*posLerp;cam3P.y+=(wy-cam3P.y)*posLerp;cam3P.z+=(wz-cam3P.z)*posLerp;camera.position.copy(cam3P);
    const la=16+sf*6;cam3L.x+=(currentX+(-sinH)*la-cam3L.x)*lookLerp;cam3L.y+=(0.50-cam3L.y)*lookLerp;cam3L.z+=(-progress+(-cosH)*la-cam3L.z)*lookLerp;
    camera.lookAt(cam3L);camera.near=0.1;const tf=64+sf*6;camera.fov+=(tf-camera.fov)*0.016;camera.updateProjectionMatrix();}}

// ── Speedometer ──────────────────────────────────────────────────────
const speedoCanvas=document.getElementById('speedo'),speedoCtx=speedoCanvas.getContext('2d');
function drawSpeedometer(spd){
  const ctx=speedoCtx,w=160,h=160,cx=w/2,cy=h/2+15,r=58;ctx.clearRect(0,0,w,h);
  const sa=Math.PI*0.75,ea=Math.PI*2.25,ta=ea-sa,gaugeMax=MAX_SPEED*0.75;
  ctx.beginPath();ctx.arc(cx,cy,r,sa,ea);ctx.strokeStyle='rgba(60,60,60,0.5)';ctx.lineWidth=3;ctx.stroke();
  for(let i=0;i<=8;i++){const a=sa+(i/8)*ta,inn=r-7,out=r+2;ctx.beginPath();ctx.moveTo(cx+Math.cos(a)*inn,cy+Math.sin(a)*inn);
    ctx.lineTo(cx+Math.cos(a)*out,cy+Math.sin(a)*out);ctx.strokeStyle=i%2===0?'rgba(180,175,165,0.45)':'rgba(140,135,125,0.25)';ctx.lineWidth=i%2===0?1.5:1;ctx.stroke();}
  const frac=Math.max(0,spd)/gaugeMax,needleA=sa+Math.min(frac,1.6)*ta;
  ctx.beginPath();ctx.moveTo(cx,cy);ctx.lineTo(cx+Math.cos(needleA)*(r-4),cy+Math.sin(needleA)*(r-4));
  ctx.strokeStyle=frac>1.0?'rgba(220,50,30,0.85)':'rgba(210,200,185,0.75)';ctx.lineWidth=1.5;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,2.5,0,Math.PI*2);ctx.fillStyle='rgba(180,175,165,0.5)';ctx.fill();}

// ── Input ────────────────────────────────────────────────────────────
const keys={};
window.addEventListener('keydown',e=>{keys[e.code]=true;if(e.code==='KeyP'&&!e.repeat)togglePause();if(e.code==='KeyR'&&crashed)restartGame();if(e.code==='KeyC'&&!e.repeat&&!crashed)cycleCamera();});
window.addEventListener('keyup',e=>{keys[e.code]=false;});

// ── Game State ───────────────────────────────────────────────────────
let loopCount=0,lastLoopIdx=0,paused=false,crashed=false;
const crashOverlay=document.getElementById('crash-overlay'),crashMsgEl=crashOverlay.querySelector('.msg'),solsEl=document.getElementById('sols');
const vhsTimestampEl=document.getElementById('vhs-timestamp');

// Nonsensical VHS timestamp generator
function updateVHSTimestamp(time){
  const chars='0123456789ABCDEFX※☆▓';
  const randomChar=()=>chars[Math.floor(Math.random()*chars.length)];
  
  // Generate impossible time values
  const h1=Math.floor(Math.random()*20);
  const h2=Math.random()<0.3?randomChar():Math.floor(Math.random()*10);
  const m1=Math.floor(Math.random()*15);
  const m2=Math.random()<0.2?randomChar():Math.floor(Math.random()*10);
  const s1=Math.floor(Math.random()*12);
  const s2=Math.random()<0.15?randomChar():Math.floor(Math.random()*10);
  
  // Occasionally glitch the separator
  const sep=Math.random()<0.05?'▓':':';
  
  vhsTimestampEl.textContent=`REC ● ${h1}${h2}${sep}${m1}${m2}${sep}${s1}${s2}`;
}

// Flash effect state
let flashActive=false;
let flashProgress=0;
const FLASH_DURATION=2.0; // seconds
let lastFlashSol=-1;

function togglePause(){if(!crashed)paused=!paused;}
function boxesOverlap(ax,az,bx,bz,hx,hz){return Math.abs(ax-bx)<hx*2&&Math.abs(az-bz)<hz*2;}

function triggerCrash(ghostRef){if(crashed)return;crashed=true;
  for(const gh of ghosts)scene.remove(gh.mesh);ghosts.length=0;allRecordings.length=0;
  if(ghostRef&&ghostRef.creationTime){const el=(performance.now()-ghostRef.creationTime)/1000;
    crashMsgEl.textContent='you killed yourself '+String(Math.floor(el/60)).padStart(2,'0')+':'+String(Math.floor(el%60)).padStart(2,'0')+' ago.';}
  else{
    const randomSeconds=5+Math.floor(Math.random()*(5*60-5));
    const mins=Math.floor(randomSeconds/60);
    const secs=randomSeconds%60;
    crashMsgEl.textContent='you killed yourself '+String(mins).padStart(2,'0')+':'+String(secs).padStart(2,'0')+' ago';
  }
  crashOverlay.classList.add('active');}

function restartGame(){crashed=false;crashOverlay.classList.remove('active');
  for(const gh of ghosts)scene.remove(gh.mesh);ghosts.length=0;allRecordings.length=0;currentRecording=[];
  progress=0;currentX=0;heading=0;speed=BASE_SPEED;prevSpeed=BASE_SPEED;steer=0;currentSteerInput=0;carPitch=0;
  loopCount=0;lastLoopIdx=0;cam3I=false;spawnObstacles(0);
  for(const lm of landmarks)scene.remove(lm);landmarks.length=0;
  damageLevel=0;playerBodyMat.color.copy(ORIGINAL_COLOR);
  const bPos=playerCar.children[1].geometry.attributes.position;
  bPos.array.set(origBodyPos);bPos.needsUpdate=true;
  playerCar.children[1].geometry.computeVertexNormals();
  wrongWayTimer=0;semiActive=false;if(semiTruck)semiTruck.visible=false;
  pedestrianActive=false;pedestrian.visible=false;nextPedestrianSol=PED_MIN_INTERVAL+Math.floor(Math.random()*(PED_MAX_INTERVAL-PED_MIN_INTERVAL));
  currentFogDensity=FOG_DENSITY;targetFogDensity=FOG_DENSITY;scene.fog.density=FOG_DENSITY;
  solsEl.textContent='';solsEl.classList.remove('sign-mode');playerCar.visible=true;
  headlightPower=1.0;hlFlickerTimer=0;hlFlickerDuration=0;
  mirrorDissonanceActive=true;stalker.visible=false;
  if(constantMountain){scene.remove(constantMountain);constantMountain=null;}
  flashActive=false;flashProgress=0;lastFlashSol=-1;
  mouseLookYaw=0;mouseLookPitch=0;targetYaw=0;targetPitch=0;
}

function lerp(a,b,t){return a+(b-a)*t;}

// ═════════════════════════════════════════════════════════════════════
let lastT=0;spawnObstacles(0);spawnLandmarks(0);
let vhsTimestampFrame=0;
function frame(ts){requestAnimationFrame(frame);const dt=Math.min((ts-lastT)/1000,0.05);lastT=ts;
  
  // Update VHS timestamp every 5 frames for ticking effect
  vhsTimestampFrame++;
  if(vhsTimestampFrame%5===0){
    updateVHSTimestamp(ts);
  }
  
  // Flash effect update
  if(flashActive){
    flashProgress+=dt;
    const t=Math.min(flashProgress/FLASH_DURATION,1.0);
    renderer.toneMappingExposure=lerp(8.0,0.76,t);
    vhsShader.uniforms.grainBoost.value=lerp(10.0,1.0,t);
    if(t>=1.0){
      flashActive=false;
      renderer.toneMappingExposure=0.76;
      vhsShader.uniforms.grainBoost.value=1.0;
    }
  }
  
  if(paused||crashed){renderer.setRenderTarget(vhsRT);renderer.setViewport(0,0,vhsRT.width,vhsRT.height);renderer.clear();renderer.render(scene,camera);
    renderer.setRenderTarget(null);renderer.setViewport(0,0,window.innerWidth,window.innerHeight);renderer.clear();vhsShader.uniforms.time.value=ts*0.001;renderer.render(vhsScene,vhsCamera);
    drawSpeedometer(0);return;}

  const targetSteer=(keys['ArrowLeft']||keys['KeyA'])?-1:(keys['ArrowRight']||keys['KeyD'])?1:0;
  currentSteerInput+=(targetSteer-currentSteerInput)*STEER_SMOOTHING;
  
  prevSpeed=speed;
  if(keys['ArrowUp']||keys['KeyW'])speed=Math.min(MAX_SPEED,speed+ACCEL);
  else if(keys['ArrowDown']||keys['KeyS']){if(speed>0)speed=Math.max(0,speed-BRAKE);else speed=Math.max(REVERSE_MAX,speed-ACCEL*0.6);}
  else{if(speed>BASE_SPEED)speed=Math.max(BASE_SPEED,speed-DRAG);else if(speed>0&&speed<BASE_SPEED)speed=Math.min(BASE_SPEED,speed+DRAG*0.4);
    else if(speed<0)speed=Math.min(0,speed+DRAG*2);}

  const absSpeed=Math.abs(speed);
  const speedFactor=Math.min(absSpeed/MAX_SPEED,1.0);
  const steerRate=STEER_SPEED_LOW+(STEER_SPEED_HIGH-STEER_SPEED_LOW)*speedFactor;
  
  const steerDir=speed>=0?1:-1;
  heading-=currentSteerInput*steerDir*steerRate*absSpeed;

  progress+=speed*Math.cos(heading);currentX-=speed*Math.sin(heading);

  // Wall collision — FIXED: damage stays white/grey but gets darker
  let wallHit=false;
  if(Math.abs(currentX)>WALL_INNER){
    const wallSide=Math.sign(currentX);currentX=wallSide*WALL_INNER;
    const impact=Math.abs(Math.sin(heading));
    if(impact>0.6){speed*=0.08;}
    else if(impact>0.25){speed*=(1-impact*0.8);}
    else{speed*=(1-impact*0.15);}
    wallHit=true;emitSparks(currentX,-progress,wallSide);
    
    // Damage darkens car uniformly (not red)
    damageLevel=Math.min(damageLevel+0.04,0.8);
    const brightness=1-damageLevel;
    playerBodyMat.color.setRGB(
      ORIGINAL_COLOR.r*brightness,
      ORIGINAL_COLOR.g*brightness,
      ORIGINAL_COLOR.b*brightness
    );
    
    const geo=playerCar.children[1].geometry;const vPos=geo.attributes.position;
    const dentStr=0.015+damageLevel*0.02;
    for(let vi=0;vi<vPos.count;vi++){
      if(Math.random()<0.08){
        vPos.setX(vi,vPos.getX(vi)+(Math.random()-0.5)*dentStr);
        vPos.setY(vi,vPos.getY(vi)+(Math.random()-0.5)*dentStr*0.5);
        vPos.setZ(vi,vPos.getZ(vi)+(Math.random()-0.5)*dentStr);}}
    vPos.needsUpdate=true;geo.computeVertexNormals();}
  updateSparks();

  // Wrong-way semi truck
  const goingWrong=Math.abs(heading)>Math.PI*0.55&&speed>0.1;
  if(goingWrong){wrongWayTimer++;
    if(wrongWayTimer>WRONG_WAY_LIMIT&&!semiActive){
      semiActive=true;semiTruck.visible=true;semiZ=-progress-120;semiTruck.position.set(currentX+(Math.random()-0.5)*3,0,semiZ);semiTruck.rotation.y=0;}
  }else{wrongWayTimer=Math.max(0,wrongWayTimer-2);}
  if(semiActive){semiZ+=1.8;semiTruck.position.z=semiZ;
    if(Math.abs(semiZ-(-progress))<4&&Math.abs(semiTruck.position.x-currentX)<2.5){
      crashMsgEl.textContent='there is no escape.';triggerCrash(null);semiActive=false;semiTruck.visible=false;}
    if(semiZ>-progress+30){semiActive=false;semiTruck.visible=false;}}

  spawnPedestrian();
  updatePedestrian();

  currentRecording.push({x:currentX,z:progress%ROAD_LENGTH,speed,drift:heading,wa:0});

  // Loop
  const curLoop=Math.floor(progress/ROAD_LENGTH);
  if(curLoop>lastLoopIdx){
    loopCount++;lastLoopIdx=curLoop;
    
    // Toggle mirror dissonance every few loops
    if(loopCount%3===0){
      mirrorDissonanceActive=!mirrorDissonanceActive;
    }
    
    if(currentRecording.length>0){allRecordings.push([...currentRecording]);ghosts.push(new Ghost(allRecordings[allRecordings.length-1],loopCount));currentRecording=[];}
    spawnObstacles(loopCount);spawnLandmarks(loopCount);
    
    // Decrease headlight power each loop
    headlightPower=Math.max(0.3,headlightPower-0.05);
  }

  const baseZ=curLoop*ROAD_LENGTH,cosH=Math.cos(heading),sinH=Math.sin(heading);
  playerCar.position.set(currentX,0,-progress);playerCar.rotation.y=heading;
  carPitch=lerp(carPitch,(speed-prevSpeed)*2.5,0.10);playerCar.rotation.x=carPitch;

  // Headlight flickering
  let hlIntensity=800*headlightPower;
  if(hlFlickerTimer>0){
    hlFlickerTimer-=dt;
    hlIntensity=Math.random()<0.5?0:hlIntensity*0.1;
  }else{
    // Random flicker events weighted by loop count
    const flickerChance=0.002+loopCount*0.0005;
    if(Math.random()<flickerChance){
      hlFlickerDuration=0.1+Math.random()*1.4;
      hlFlickerTimer=hlFlickerDuration;
    }
  }
  
  const hlZ=-2.5;
  hlL.position.set(currentX+(-0.46)*cosH+hlZ*sinH,0.25,-progress+(0.46*sinH+hlZ*cosH));
  hlR.position.set(currentX+0.46*cosH+hlZ*sinH,0.25,-progress+(-0.46*sinH+hlZ*cosH));
  hlL.intensity=hlIntensity;
  hlR.intensity=hlIntensity;

  const braking=keys['ArrowDown']||keys['KeyS'];
  tailGlow.intensity=braking?BRAKE_GLOW_MAX:BRAKE_GLOW_IDLE;
  tailGlow.distance=braking?22:12;
  tailGlow.position.set(currentX+2.0*sinH,0.40,-progress+2.0*cosH);

  emitSpray(cosH,sinH);updateSpray();

  arrowMesh.position.set(currentX,1.6,-progress);arrowMesh.rotation.x=-Math.PI/2;arrowMesh.rotation.z=0;
  if(cameraMode===1)arrowMesh.lookAt(camera.position);

  const si=Math.floor(progress/ROAD_LENGTH);for(let i=0;i<3;i++)segments[i].position.z=-(si-1+i)*ROAD_LENGTH;

  updateLamps(progress);updateLampFlicker();

  // The Stalker - follows 60 units behind
  stalker.position.set(currentX,0,-progress+60);
  stalker.rotation.y=heading;
  
  // Toggle stalker visibility based on mirror dissonance
  stalker.visible=!mirrorDissonanceActive;

  // Ghosts + collision
  const pWZ=-progress;
  for(let i=ghosts.length-1;i>=0;i--){
    const gh=ghosts[i];
    gh.update(baseZ);
    
    // Hide ghosts when stalker is active
    gh.mesh.visible=mirrorDissonanceActive;
    
    if(gh.isStationary()){
      scene.remove(gh.mesh);
      ghosts.splice(i,1);
      continue;
    }
    
    if(gh.merged){
      const gp=gh.getWorldXZ();
      if(boxesOverlap(currentX,pWZ,gp.x,gp.z,COL_HX,COL_HZ)){
        triggerCrash(gh);
        break;
      }
    }
  }
  
  // Obstacles
  for(let i=liveObstacles.length-1;i>=0;i--){
    const ob=liveObstacles[i];
    ob.mesh.position.z=-(baseZ+ob.oz);
    ob.mesh.position.x=ob.ox;
    
    const dx=ob.mesh.position.x-ob.lastPos.x;
    const dz=ob.mesh.position.z-ob.lastPos.z;
    const moved=Math.abs(dx)+Math.abs(dz);
    if(moved<0.01){ob.stationaryFrames++;}
    else{ob.stationaryFrames=0;}
    ob.lastPos.x=ob.mesh.position.x;
    ob.lastPos.z=ob.mesh.position.z;
    
    if(ob.stationaryFrames>60){
      scene.remove(ob.mesh);
      liveObstacles.splice(i,1);
      continue;
    }
    
    if(boxesOverlap(currentX,pWZ,ob.ox,ob.mesh.position.z,COL_HX,COL_HZ))triggerCrash(null);
  }

  updateSigns(progress);tickRain(playerCar.position);

  // The Constant Mountain logic
  if(constantMountain){
    const baseZLM=curLoop*ROAD_LENGTH;
    
    if(loopCount>=1&&loopCount<=3){
      // Maintain constant distance
      constantMountain.position.z=-progress-mountainInitialDistance;
    }else if(loopCount===4){
      // Glitch - jump closer and jitter
      const jitterX=(Math.random()-0.5)*5;
      const jitterY=(Math.random()-0.5)*3;
      const jitterZ=(Math.random()-0.5)*5;
      constantMountain.position.set(150+jitterX,jitterY,-progress-150+jitterZ);
    }else if(loopCount>4){
      // Continue jittering
      constantMountain.position.x=150+(Math.random()-0.5)*8;
      constantMountain.position.y=(Math.random()-0.5)*4;
      constantMountain.position.z=-progress-150+(Math.random()-0.5)*8;
    }
  }

  let nearSign=false;
  for(let si2=0;si2<NUM_SIGN_SLOTS;si2++){if(Math.abs(roadSigns[si2].position.z-(-progress))<40){nearSign=true;solsEl.textContent=roadSigns[si2].userData.text||'';
    if(!solsEl.classList.contains('sign-mode'))solsEl.classList.add('sign-mode');break;}}
  if(!nearSign&&solsEl.classList.contains('sign-mode'))solsEl.classList.remove('sign-mode');

  // Fog event
  const sols=Math.floor(progress/10);
  if(sols>=100&&sols<=150)targetFogDensity=0.08;else targetFogDensity=FOG_DENSITY;
  currentFogDensity+=(targetFogDensity-currentFogDensity)*0.008;
  scene.fog.density=currentFogDensity;
  
  // Magnesium Artillery Flash
  if(sols>0&&sols%1000===0&&sols!==lastFlashSol){
    flashActive=true;
    flashProgress=0;
    lastFlashSol=sols;
  }

  const baseZLM=curLoop*ROAD_LENGTH;
  for(const lm of landmarks){lm.position.z=-(baseZLM+lm.userData.oz);}

  updateCameraSystem(speed);drawSpeedometer(speed);

  renderer.setRenderTarget(vhsRT);renderer.setViewport(0,0,vhsRT.width,vhsRT.height);renderer.clear();renderer.render(scene,camera);
  const mR=mirrorEl.getBoundingClientRect(),vsX=vhsRT.width/window.innerWidth,vsY=vhsRT.height/window.innerHeight;
  const mvX=Math.round(mR.left*vsX),mvY=Math.round((window.innerHeight-mR.bottom)*vsY),mvW=Math.round(mR.width*vsX),mvH=Math.round(mR.height*vsY);
  if(mvW>0&&mvH>0){mirrorCam.position.set(currentX+0.2*sinH,1.05,-progress+0.2*cosH);mirrorCam.lookAt(currentX+sinH*80,0.85,-progress+cosH*80);
    const oF=scene.fog.density,oE=renderer.toneMappingExposure;scene.fog.density=FOG_DENSITY*1.2;renderer.toneMappingExposure=0.40;
    renderer.clearDepth();renderer.setViewport(mvX,mvY,mvW,mvH);renderer.setScissor(mvX,mvY,mvW,mvH);renderer.setScissorTest(true);
    renderer.render(scene,mirrorCam);renderer.setScissorTest(false);scene.fog.density=oF;renderer.toneMappingExposure=oE;}
  renderer.setRenderTarget(null);renderer.setViewport(0,0,window.innerWidth,window.innerHeight);renderer.clear();vhsShader.uniforms.time.value=ts*0.001;renderer.render(vhsScene,vhsCamera);
}
requestAnimationFrame(frame);
</script>
</body>
</html>
